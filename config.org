#+TITLE: Emacs Configuration
#+AUTHOR: John Allen
#+STARTUP: overview
* Use dash
  Because dash is awesome
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package dash)
  #+END_SRC

* Path Fix for Mac
  Mac tries to hide your $PATH from you when using a graphical mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :config
    (exec-path-from-shell-initialize))
#+END_SRC
* Customization File
#+begin_src emacs-lisp :tangle yes
  (setq custom-file (concat config-load-path "custom.el"))
  (load custom-file)
#+end_src
* Toggle Magic
  https://endlessparentheses.com/the-toggle-map-and-wizardry.html
#+begin_src emacs-lisp :tangle yes
  (define-prefix-command 'endless/toggle-map)
  ;; The manual recommends C-c for user keys, but C-x t is
  ;; always free, whereas C-c t is used by some modes.
  (define-key ctl-x-map "t" 'endless/toggle-map)
  (define-key endless/toggle-map "c" #'column-number-mode)
  (define-key endless/toggle-map "d" #'toggle-debug-on-error)
  (define-key endless/toggle-map "e" #'toggle-debug-on-error)
  (define-key endless/toggle-map "f" #'auto-fill-mode)
  (define-key endless/toggle-map "l" #'toggle-truncate-lines)
  (define-key endless/toggle-map "q" #'toggle-debug-on-quit)
  (define-key endless/toggle-map "t" #'endless/toggle-theme)
  ;;; Generalized version of `read-only-mode'.
  (define-key endless/toggle-map "r" #'dired-toggle-read-only)
  (autoload 'dired-toggle-read-only "dired" nil t)
  (define-key endless/toggle-map "w" #'whitespace-mode)
#+end_src

* Configure Helm
  Make everything fuzzy and also rebind functions.
  #+begin_src emacs-lisp :tangle yes
    (use-package flx)

    (use-package helm-flx)
    (use-package helm-descbinds)
    (use-package helm
      :demand
      :diminish helm-mode
      :bind (("M-x" . helm-M-x)
             ("M-y" . helm-show-kill-ring)
             ("C-x b" . helm-mini)
             ("C-x C-f" . helm-find-files)
             ("C-x r l" . helm-bookmarks)
             ("C-c C-i" . helm-semantic-or-imenu)
             :map helm-find-files-map ;; I like these from Ido
             ;; ("C-<tab>" . helm-execute-persistent-action)
             ("<tab>" . helm-execute-persistent-action)
             ("C-i" . helm-execute-persistent-action)
             ("C-<backspace>" . helm-find-files-up-one-level))
      :config
      (helm-mode 1)
      (helm-descbinds-mode)
      (helm-flx-mode +1)
      (setq helm-M-x-fuzzy-match t
            helm-buffers-fuzzy-matching t
            helm-recentf-fuzzy-match t
            helm-locate-fuzzy-match t
            helm-lisp-fuzzy-completion t
            helm-bookmark-show-location t))
    (use-package helm-xref
    :config
      (setq xref-show-xrefs-function 'helm-xref-show-xrefs))

  #+end_src
* Configuring =org-mode=
** Set environment
#+begin_src emacs-lisp :tangle yes
  (setq org-enforce-todo-dependencies t)
  (setq org-agenda-sticky t)
  (setq org-cycle-separator-lines 0)

  (setq org-directory "~/org/"
        org-tags-exclude-from-inheritance '("BUCKET" "PROJECTS"))

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (defun org-find-file ()
    "Leverage Helm to quickly open any org files."
    (interactive)
    (find-file (concat org-directory
                       (helm-comp-read "Select your org file: "
                                       (directory-files org-directory nil "\.org$")))))


  (eval-after-load "org"
    '(defun org-save-all-org-buffers ()
       (interactive)
       "org-save-all-org-buffers saves agenda buffers annoyingly..."
       (save-some-buffers t (lambda () (and (derived-mode-p 'org-mode)
                                            (not (derived-mode-p 'org-agenda-mode))
                                            )))
       (when (featurep 'org-id) (org-id-locations-save))
       (message "Saving all org buffers... done")))

  ;; Auto save all buffers in agenda mode
  (add-hook 'org-agenda-mode-hook
            (lambda ()
              (define-key org-agenda-mode-map "Y" 'org-todo-yesterday)
              (define-key org-agenda-mode-map "P" 'org-pomodoro)
              (define-key org-agenda-mode-map "N" nil)
              (cd "/tmp")
              (add-hook 'auto-save-hook 'org-save-all-org-buffers nil t)
              (auto-save-mode)))
#+end_src

** Modules

We ensure that we load org-habit and org-protocol

#+begin_src emacs-lisp :tangle yes
  (setq-default org-modules
                '(org-bibtex
                  org-habit
                  org-id
                  org-info
                  org-protocol))
#+end_src

** Enable =org-mode= for org files

#+begin_src emacs-lisp :tangle yes
(use-package org
  :mode ("\\.org\\'" . org-mode)
  :mode ("\\.org_archive\\'" . org-mode))
#+end_src

** GTD TODO, tags, effort

  TAGS: { project(p) }
  TAGS: { @home(h) @office(o) @travelling(t) @phone(p) @email(m) @errands(e) }

  #+begin_src emacs-lisp :tangle yes
    (setq org-global-properties
          '(("Effort_ALL". "0:05 0:30 1:00 2:00 4:00 8:00")))

    (setq org-todo-keywords
          (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                  (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING")))

          org-todo-keyword-faces
          (quote (("TODO" :foreground "red" :weight bold)
                  ("NEXT" :foreground "blue" :weight bold)
                  ("DONE" :foreground "forest green" :weight bold)
                  ("WAITING" :foreground "orange" :weight bold)
                  ("HOLD" :foreground "magenta" :weight bold)
                  ("CANCELLED" :foreground "forest green" :weight bold)
                  ("MEETING" :foreground "forest green" :weight bold)
                  ("PHONE" :foreground "forest green" :weight bold)))

          org-todo-state-tags-triggers
          (quote (("CANCELLED" ("CANCELLED" . t))
                  ("WAITING" ("WAITING" . t))
                  ("HOLD" ("WAITING") ("HOLD" . t))
                  (done ("WAITING") ("HOLD"))
                  ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                  ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                  ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))))

          org-tag-alist
          '((:startgroup)
            ("@anywhere" . ?a)
            (:grouptags) ; mutually exclusive
            ("@work" . ?w)
            ("@fablab" . ?f)
            ("@sag" . ?s)
            ("@weekend" . ?W)
            ("@computer" . ?c)
            ("@errands" . ?e)
            ("@home" .?h)
            (:endgroup)


            ;; home subgroup
            (:startgroup)
            ("@home" . ?h)
            (:grouptags) ; mutually exclusive
            ("@basement" . ?b)
            ("@roof" . ?r)
            (:endgroup)

            (:startgrouptag)
            ("@work" . ?w)
            (:grouptags) ; not mutually exclusive
            ("francis" . ?F)
            ("dave" . ?D)
            ("madhura" . ?M)
            ("lenni" . ?L)
            ("saurabh" . ?S)
            ("goth" . ?G)
            ("Roadmap" . ?R)
            (:endgrouptag)

            (:startgrouptag)
            ("Roadmap" . ?R)
            (:grouptags) ; not mutually exclusive
            ;; TODO make this a regex...
            ("H12019" . ?1)
            ("H22019" . ?2)
            ("H12020" . ?3)
            ("H22020" . ?4)
            (:endgrouptag)

            (:startgrouptag)
            ("Family" . ?A)
            (:grouptags) ; not mutually exclusive
            ("genevieve" . ?g)
            ("mimi" . ?m)
            ("dinny" . ?l)
            ("kids" . ?k)
            (:endgrouptag)

            ))

  #+end_src
** Pretty headlines
*** Make headlines more compact
#+begin_src emacs-lisp :tangle yes
  (setq org-hide-leading-stars t
        org-ellipsis "â¤µ"
        org-tags-column 80)
#+end_src
*** Start folded by default
#+begin_src emacs-lisp :tangle yes
    (setq org-startup-folded 'content)
#+end_src
*** Make all headline levels the same size
#+begin_src emacs-lisp :tangle yes
  (set-face-attribute 'org-level-1 nil :foreground "dodger blue" :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-2 nil :foreground "#edd400" :weight 'bold :height 1.0)
#+end_src
** Columns, get your columns here

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-columns-default-format "%50ITEM(Task) %2PRIORITY %10Effort(Effort){:} %10CLOCKSUM")

#+END_SRC

** Enter follows links at point

   Because how the hell else should it work?
#+begin_src emacs-lisp :tangle yes
  (setq org-return-follows-link t)
#+end_src

** Src blocks
*** Intentation and fontification
#+begin_src emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)

  (defun my/org-cleanup ()
    (interactive)
    (org-edit-special)
    (indent-region (point-min) (point-max))
    (org-edit-src-exit))

  (define-key org-mode-map (kbd "C-M-<tab>") 'my/org-cleanup)

  ;; (org-element-map (org-element-parse-buffer) 'src-block

  ;;   (lambda (src-block)
  ;;     (message src-block)
  ;;     ))
#+end_src

*** Just evaluate it, don't backtalk me
#+begin_src emacs-lisp :tangle yes
  (setq org-confirm-babel-evaluate nil)
#+end_src

** Set up global keys
#+begin_src emacs-lisp :tangle yes
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-switchb)
#+end_src
** Speed commands
These are speed commands. They make the ORG go faster.

I remove the bulk of the defaults because I really don't use many of these features...
#+begin_src emacs-lisp :tangle yes
  (setq org-use-speed-commands t
        org-speed-commands-user '(("Outline Navigation")
                                  ("u" . ignore)
                                  ("j" . ignore)
                                  ("g" org-refile t) ; goto a refile location
                                  ("c" . ignore)
                                  ("C" . ignore)
                                  (" " . ignore)
                                  ("s" . org-narrow-to-subtree)
                                  ("=" . ignore)
                                  ("Outline Structure Editing")
                                  ("U" . ignore)
                                  ("D" . ignore)
                                  ("r" org-todo 'right)
                                  ("l" org-todo 'left)
                                  ("R" . ignore)
                                  ("L" . ignore)
                                  ("i" progn
                                   (forward-char 1)
                                   (call-interactively 'org-insert-todo-heading-respect-content))
                                  ("S" progn
                                   (forward-char 1)
                                   (call-interactively 'org-insert-todo-heading-respect-content)
                                   (org-demote-subtree))
                                  ("N" progn
                                   (forward-char 1)
                                   (org-insert-todo-heading-respect-content 2)
                                   (org-todo "NEXT")
                                   (org-demote-subtree))
                                  ("^" . ignore)
                                  ("w" . org-refile)
                                  ("a" . org-archive-subtree-default-with-confirmation)
                                  ("@" . org-mark-subtree)
                                  ("#" . org-toggle-comment)
                                  ("Clock Commands")
                                  ("P" . org-pomodoro)
                                  ("I" . org-clock-in)
                                  ("O" . org-clock-out)
                                  ("Meta Data Editing")
                                  ("T" . org-todo)
                                  ("," ignore)
                                  ("0" progn (org-delete-property "EFFORT"))
                                  ("1" progn (org-set-effort 1))
                                  ("2" progn (org-set-effort 2))
                                  ("3" progn (org-set-effort 3))
                                  ("4" progn (org-set-effort 4))
                                  ("5" progn (org-set-effort 5))
                                  (":" . org-set-tags-command)
                                  ;;("e" . ignore)
                                  ("E" . ignore)
                                  ("W" . widen)
                                  ("Agenda Views etc")
                                  ("v" . org-agenda)
                                  ("/" . org-sparse-tree)
                                  ("Misc")
                                  ("o" . org-open-at-point)
                                  ("?" . org-speed-command-help)
                                  ("<" org-agenda-set-restriction-lock 'subtree)
                                  (">" org-agenda-remove-restriction-lock)))


  ;;org-speed-commands-user '(("5" (lambda () (org-toggle-tag "read")))))
#+end_src

** Special files

  #+begin_src emacs-lisp :tangle yes
    (setq jallen-org-notes-file (concat org-directory "notes.org")
          jallen-org-gtd-file (concat org-directory "gtd.org")
          jallen-org-reference-file (concat org-directory "reference.org")
          jallen-org-chores-file (concat org-directory "chores.org")
          jallen-org-habits-file (concat org-directory "habits.org")

          jallen-org-journal-file (concat org-directory "journal.org")
          jallen-org-5-min-journal-file (concat org-directory "5-min-journal.org")
          jallen-org-weekly-report-file (concat org-directory "weekly.org")
          jallen-org-cbt-journal-file (concat org-directory "cbt-journal.org")
          jallen-org-diet-journal-file (concat org-directory "diet-journal.org")
          jallen-org-sync-calendar (concat org-directory "cal.org")

          ;; TODO we have a separate habits file to allos beorg to ignore habits. this is a bit unfortunate
          jallen-default-org-agenda-files (list jallen-org-gtd-file)
          org-default-notes-file jallen-org-notes-file
          org-agenda-files jallen-default-org-agenda-files)

  #+end_src
** Refiling
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Also enable based on a project tag?
  (defun jallen/filter-refile-targets ()
    (or (member "BUCKET" (org-get-tags))
        (bh/is-project-p)))

  (setq org-outline-path-complete-in-steps nil
        org-refile-allow-creating-parent-nodes 'confirm
        org-refile-use-outline-path t
        org-refile-target-verify-function 'jallen/filter-refile-targets

        org-refile-targets '((jallen-org-gtd-file :maxlevel . 4)
                             (jallen-org-reference-file :maxlevel . 4)))
#+END_SRC

** Agendas configurations
   :PROPERTIES:
   :ORDERED:  t
   :END:
*** Random sorting
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun org-random-cmp (a b)
    "Return -1,0 or 1 randomly"
    (- (mod (random) 3) 1))
#+END_SRC

*** Agenda helpers

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun random-cmp (a b)
       "Randomly returns 1 and -1 with equal probability and nil with a neglibible probability"
       (let ((rnd1 (random))
             (rnd2 (random)))
         (if (> rnd1 rnd2) 1 (if (< rnd1 rnd2) -1 nil))))

     (defun bh/find-project-task ()
       "Move point to the parent (project) task if any"
       (save-restriction
         (widen)
         (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
           (while (org-up-heading-safe)
             (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
               (setq parent-task (point))))
           (goto-char parent-task)
           parent-task)))

     (defun bh/is-project-p ()
       "Any task with a todo keyword subtask"
       (save-restriction
         (widen)
         (let ((has-subtask)
               (subtree-end (save-excursion (org-end-of-subtree t)))
               (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
           (and is-a-task
                (or (save-excursion
                      (org-up-heading-safe)
                      (member "PROJECTS" (org-get-tags)))
                    (save-excursion
                      (forward-line 1)
                      (while (and (not has-subtask)
                                  (< (point) subtree-end)
                                  (re-search-forward "^\*+ " subtree-end t))
                        (when (member (org-get-todo-state) org-todo-keywords-1)
                          (setq has-subtask t))))
                    )))))

     (defun bh/is-project-subtree-p ()
       "Any task with a todo keyword that is in a project subtree.
        Callers of this function already widen the buffer view."
       (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                   (point))))
         (save-excursion
           (bh/find-project-task)
           (if (equal (point) task)
               nil
             t))))

     (defun bh/is-task-p ()
       "Any task with a todo keyword and no subtask"
       (save-restriction
         (widen)
         (let ((has-subtask)
               (subtree-end (save-excursion (org-end-of-subtree t)))
               (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
           (save-excursion
             (forward-line 1)
             (while (and (not has-subtask)
                         (< (point) subtree-end)
                         (re-search-forward "^\*+ " subtree-end t))
               (when (member (org-get-todo-state) org-todo-keywords-1)
                 (setq has-subtask t))))
           (and is-a-task (not has-subtask)))))

     (defun bh/is-subproject-p ()
       "Any task which is a subtask of another project"
       (let ((is-subproject)
             (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
         (save-excursion
           (while (and (not is-subproject) (org-up-heading-safe))
             (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
               (setq is-subproject t))))
         (and is-a-task is-subproject)))

     (defun bh/list-sublevels-for-projects-indented ()
       "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
       (if (marker-buffer org-agenda-restrict-begin)
           (setq org-tags-match-list-sublevels 'indented)
         (setq org-tags-match-list-sublevels nil))
       nil)

     (defun bh/list-sublevels-for-projects ()
       "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
       (if (marker-buffer org-agenda-restrict-begin)
           (setq org-tags-match-list-sublevels t)
         (setq org-tags-match-list-sublevels nil))
       nil)

     (defvar bh/hide-scheduled-and-waiting-next-tasks t)

     (defun bh/toggle-next-task-display ()
       (interactive)
       (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
       (when  (equal major-mode 'org-agenda-mode)
         (org-agenda-redo))
       (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

     (defun bh/skip-stuck-projects ()
       "Skip trees that are not stuck projects"
       (save-restriction
         (widen)
         (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
           (if (bh/is-project-p)
               (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                      (has-next ))
                 (save-excursion
                   (forward-line 1)
                   (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                     (unless (member "WAITING" (org-get-tags-at))
                       (setq has-next t))))
                 (if has-next
                     nil
                   next-headline)) ; a stuck project, has subtasks but no next task
             nil))))

     (defun bh/skip-non-stuck-projects ()
       "Skip trees that are not stuck projects"
       ;; (bh/list-sublevels-for-projects-indented)
       (save-restriction
         (widen)
         (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
           (if (bh/is-project-p)
               (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                      (has-next ))
                 (save-excursion
                   (forward-line 1)
                   (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                     (unless (member "WAITING" (org-get-tags-at))
                       (setq has-next t))))
                 (if has-next
                     next-headline
                   nil)) ; a stuck project, has subtasks but no next task
             next-headline))))

     (defun bh/skip-non-projects ()
       "Skip trees that are not projects"
       ;; (bh/list-sublevels-for-projects-indented)
       (if (save-excursion (bh/skip-non-stuck-projects))
           (save-restriction
             (widen)
             (let ((subtree-end (save-excursion (org-end-of-subtree t))))
               (cond
                ((bh/is-project-p)
                 nil)
                ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
                 nil)
                (t
                 subtree-end))))
         (save-excursion (org-end-of-subtree t))))

     (defun bh/skip-non-tasks ()
       "Show non-project tasks.
        Skip project and sub-project tasks, habits, and project related tasks."
       (save-restriction
         (widen)
         (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
           (cond
            ((bh/is-task-p)
             nil)
            (t
             next-headline)))))

     (defun bh/skip-project-trees-and-habits ()
       "Skip trees that are projects"
       (save-restriction
         (widen)
         (let ((subtree-end (save-excursion (org-end-of-subtree t))))
           (cond
            ((bh/is-project-p)
             subtree-end)
            ((org-is-habit-p)
             subtree-end)
            (t
             nil)))))

     (defun bh/skip-projects-and-habits-and-single-tasks ()
       "Skip trees that are projects, tasks that are habits, single non-project tasks"
       (save-restriction
         (widen)
         (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
           (cond
            ((org-is-habit-p)
             next-headline)
            ((and bh/hide-scheduled-and-waiting-next-tasks
                  (member "WAITING" (org-get-tags-at)))
             next-headline)
            ((bh/is-project-p)
             next-headline)
            ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
             next-headline)
            (t
             nil)))))

     (defun bh/skip-project-tasks-maybe ()
       "Show tasks related to the current restriction.
        When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
        When not restricted, skip project and sub-project tasks, habits, and project related tasks."
       (save-restriction
         (widen)
         (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                (next-headline (save-excursion (or (outline-next-heading) (point-max))))
                (limit-to-project (marker-buffer org-agenda-restrict-begin)))
           (cond
            ((bh/is-project-p)
             next-headline)
            ((org-is-habit-p)
             subtree-end)
            ((and (not limit-to-project)
                  (bh/is-project-subtree-p))
             subtree-end)
            ((and limit-to-project
                  (bh/is-project-subtree-p)
                  (member (org-get-todo-state) (list "NEXT")))
             subtree-end)
            (t
             nil)))))

     (defun bh/skip-project-tasks ()
       "Show non-project tasks.
        Skip project and sub-project tasks, habits, and project related tasks."
       (save-restriction
         (widen)
         (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
           (cond
            ((bh/is-project-p)
             subtree-end)
            ((org-is-habit-p)
             subtree-end)
            ((bh/is-project-subtree-p)
             subtree-end)
            (t
             nil)))))

     (defun bh/skip-non-project-tasks ()
       "Show project tasks.
        Skip project and sub-project tasks, habits, and loose non-project tasks."
       (save-restriction
         (widen)
         (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
           (cond
            ((bh/is-project-p)
             next-headline)
            ((org-is-habit-p)
             subtree-end)
            ((and (bh/is-project-subtree-p)
                  (member (org-get-todo-state) (list "NEXT")))
             subtree-end)
            ((not (bh/is-project-subtree-p))
             subtree-end)
            (t
             nil)))))

     (defun bh/skip-projects-and-habits ()
       "Skip trees that are projects and tasks that are habits"
       (save-restriction
         (widen)
         (let ((subtree-end (save-excursion (org-end-of-subtree t))))
           (cond
            ((bh/is-project-p)
             subtree-end)
            ((org-is-habit-p)
             subtree-end)
            (t
             nil)))))

     (defun jra3/skip-habits-on-hold ()
       "Skip habit tasks that are hold TODO status"
       (save-restriction
         (widen)
         (let ((subtree-end (save-excursion (org-end-of-subtree t))))
           (cond
            ((and (org-is-habit-p)
                  (member (org-get-todo-state) (list "HOLD")))
             subtree-end)
            (t
             nil)))))

     (defun bh/skip-non-subprojects ()
       "Skip trees that are not projects"
       (let ((next-headline (save-excursion (outline-next-heading))))
         (if (bh/is-subproject-p)
             nil
           next-headline)))

     (defun org-agenda-skip-if-scheduled-later ()
       "If this function returns nil, the current match should not be skipped.
        Otherwise, the function must return a position from where the search
        should be continued."
       (ignore-errors
         (let ((subtree-end (save-excursion (org-end-of-subtree t)))
               (scheduled-seconds
                (time-to-seconds
                 (org-time-string-to-time
                  (org-entry-get nil "SCHEDULED"))))
               (now (time-to-seconds (current-time))))
           (and scheduled-seconds
                (>= scheduled-seconds now)
                subtree-end))))

     (defun my-org-agenda-skip-all-siblings-but-first ()
       "Skip all but the first non-done entry."
       (let (should-skip-entry)
         (unless (org-current-is-todo)
           (setq should-skip-entry t))
         (save-excursion
           (while (and (not should-skip-entry) (org-goto-sibling t))
             (when (org-current-is-todo)
               (setq should-skip-entry t))))
         (when should-skip-entry
           (or (outline-next-heading)
               (goto-char (point-max))))))

     (defun org-current-is-todo ()
       (string= "TODO" (org-get-todo-state)))

   #+END_SRC
*** Custom commands

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq jallen-oacc-refile
           '(tags-todo "REFILE"
                       ((org-agenda-overriding-header "Tasks to Refile")
                        (org-tags-match-list-sublevels nil)))

           jallen-oacc-read
           '(tags-todo "read"
                       ((org-agenda-overriding-header "Reading List")
                        (org-tags-match-list-sublevels nil)))

           jallen-oacc-projects
           '(tags-todo "-CANCELLED-CATEGORY=\"Someday\"-CATEGORY=\"Tickler\"/!"
                       ((org-agenda-overriding-header "Projects")
                        (org-agenda-skip-function 'bh/skip-non-projects)
                        (org-tags-match-list-sublevels 'indented)
                        ))

           jallen-oacc-stuck
           '(tags-todo "-CANCELLED-CATEGORY=\"Someday\"-CATEGORY=\"Tickler\"/!"
                       ((org-agenda-overriding-header "Stuck Projects")
                        (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                        (org-agenda-sorting-strategy '(todo-state-up))
                        ))

           jallen-oacc-today
           '(agenda ""
                    ((org-agenda-overriding-header "Agenda:")
                     (org-agenda-span 'day)
                     (org-agenda-ndays 30)
                     (org-agenda-start-on-weekday nil)
                     (org-agenda-start-day "+0d")
                     (org-agenda-show-all-dates nil)
                     (org-agenda-files (list jallen-org-gtd-file jallen-org-sync-calendar))
                     (org-agenda-todo-ignore-deadlines nil)))

           jallen-oacc-habits
           '(agenda ""
                    ((org-agenda-overriding-header "Habits:")
                     (org-agenda-remove-tags t)
                     (org-agenda-use-time-grid nil)
                     (org-agenda-files (list jallen-org-habits-file))
                     (org-agenda-skip-function 'jra3/skip-habits-on-hold)
                     (org-agenda-span 'day)
                     (org-agenda-ndays 30)
                     (org-agenda-start-on-weekday nil)
                     (org-agenda-start-day "+0d")
                     (org-agenda-todo-ignore-deadlines nil)))

           jallen-oacc-chores
           '(agenda ""
                    ((org-agenda-overriding-header "Chores:")
                     (org-agenda-remove-tags t)
                     (org-agenda-files (list jallen-org-chores-file))
                     (org-agenda-span 7)
                     (org-agenda-ndays 60)
                     (org-agenda-show-all-dates nil)
                     (org-agenda-todo-ignore-deadlines nil)))

           jallen-oacc-next
           '(tags-todo "-CANCELLED-CATEGORY=\"Someday\"-CATEGORY=\"Tickler\"/!NEXT"
                       ((org-agenda-overriding-header (concat "Next Actions"
                                                              (if bh/hide-scheduled-and-waiting-next-tasks
                                                                  ""
                                                                " (including WAITING and SCHEDULED tasks)")))
                        (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                        (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                        (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                        (org-agenda-skip-function 'bh/skip-projects-and-habits)
                        (org-tags-match-list-sublevels t)
                        ;; random sorting so I don't stare at the meaningless order
                        ;; (org-agenda-cmp-user-defined 'org-random-cmp)
                        (org-agenda-sorting-strategy '(effort-up))
                        ))

           jallen-oacc-waiting
           '(tags-todo "-CATEGORY=\"Someday\"-CATEGORY=\"Tickler\"-CANCELLED+WAITING|HOLD/!"
                       ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                              (if bh/hide-scheduled-and-waiting-next-tasks
                                                                  ""
                                                                " (including WAITING and SCHEDULED tasks)")))
                        (org-agenda-skip-function 'bh/skip-non-tasks)
                        (org-tags-match-list-sublevels nil)
                        (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                        (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))

           org-agenda-custom-commands
           (list
            (list "r" "Read"
                  (list jallen-oacc-read
                        ))

            (list "C" "Clarify"
                  (list jallen-oacc-refile
                        jallen-oacc-stuck
                        ))

            (list "j" "GTD"
                  (list jallen-oacc-today
                        jallen-oacc-habits
                        jallen-oacc-next
                        jallen-oacc-stuck
                        jallen-oacc-projects
                        jallen-oacc-chores
                        jallen-oacc-waiting))))
   #+END_SRC

*** Agenda faces

    #+begin_src emacs-lisp :tangle yes
      (defface my-org-deadline-yesterday
        '((t (:foreground "#F45B69" :weight bold)))
        "Agenda deadlines overdue")
      (defface my-org-deadline-today
        '((t (:foreground "#FAFFFD" :weight bold)))
        "Agenda deadlines iminent")
      (defface my-org-deadline-tomorrow
        '((t (:foreground "#9FD356")))
        "Agenda deadlines soon")
      (defface my-org-deadline-later
        '((t (:foreground "#3C91E6")))
        "Agenda deadlines far in the future")
      (defface my-org-deadline-someday
        '((t (:foreground "#0A2463")))
        "Agenda deadlines far in the future")

      ;; faces for showing deadlines in the agenda
      (setq org-agenda-deadline-faces
            '((1.01 . my-org-deadline-yesterday)
              (0.99 . my-org-deadline-today)
              (0.69 . my-org-deadline-tomorrow)
              (0.49 . my-org-deadline-later)
              (0.00 . my-org-deadline-someday)))
    #+end_src
*** Highlight the line that the point is on
#+begin_src emacs-lisp :tangle yes
  (add-hook 'org-agenda-finalize-hook (lambda () (hl-line-mode)))
#+end_src
*** Buffer setup
  #+begin_src emacs-lisp :tangle yes
    (setq org-agenda-use-time-grid t
          org-agenda-dim-blocked-tasks nil ;; Do not dim blocked tasks
          org-agenda-compact-blocks nil      ;; Compact the block agenda view
          org-agenda-restore-windows-after-quit t
          org-agenda-start-on-weekday nil
          org-agenda-span 1
          org-agenda-window-setup 'current-window)
  #+end_src
*** org-goto should use a narrowed view
    I find this much more readable
    #+begin_src emacs-lisp :tangle yes
      (advice-add 'org-agenda-goto :after
                  (lambda (&rest args)
                    (org-show-children)
                    (org-narrow-to-subtree)))
    #+end_src


** No Priorities
#+BEGIN_SRC emacs-lisp tangle: yes
(setq org-enable-priority-commands nil)
#+END_SRC

** Clocks
*** Org Pomodoro
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-pomodoro)
#+END_SRC

*** Logging time of task completion
#+begin_src emacs-lisp :tangle yes
  (setq org-log-done 'time ; log the time a task is marked done
        org-clock-out-remove-zero-time-clocks t
        org-log-into-drawer t) ; timestamps go in a drawer, not the body
#+end_src
*** Editing timestamps

#+begin_src emacs-lisp :tangle yes
  (setq org-edit-timestamp-down-means-later t)
#+end_src

*** Save the running clock and all clock history when exiting Emacs, load it on startp
#+begin_src emacs-lisp :tangle yes
  (org-clock-persistence-insinuate)
  (setq org-clock-persist 'history
        org-clock-in-resume t)
#+end_src

*** org-clocking-luxafor

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Some of the usual Luxafor patterns.
  (defconst org-clocking-luxafor-patterns
    '(
      off    "off"
      red    "set f00"
      yellow "set ff0"
      over   "flash ff0"
      green  "set 0f0")
    "Simple strings to pass to script")

  (defvar org-clocking-luxafor-off-pattern 'off
    "Luxafor pattern to use for 'org-mode' clock-in.")
  (defvar org-clocking-luxafor-clock-in-pattern 'red
    "Luxafor pattern to use for 'org-mode' clock-in.")
  (defvar org-clocking-luxafor-clock-out-pattern 'green
    "Luxafor pattern to use for 'org-mode' clock-out.")
  (defvar org-clocking-luxafor-break-over-pattern 'over
    "Luxafor pattern to use for 'org-mode' clock-out.")
  (defvar org-clocking-luxafor-break-really-over-pattern 'yellow
    "Luxafor pattern to use for 'org-mode' clock-out.")

  (defun org-clocking-luxafor-change-pattern (pattern)
    "Given the PATTERN name, write the associated raw byte string
      to the Luxafor device."
    (let ((pattern-string (plist-get org-clocking-luxafor-patterns pattern)))
      (message pattern-string)
      (when pattern-string
        (shell-command-to-string
         (format "node ~/.emacs.d/lux/luxafor-set.js %s" pattern-string)))))

  (defun org-clocking-luxafor-off ()
    (org-clocking-luxafor-change-pattern org-clocking-luxafor-off-pattern)
    ;; Return true, so the hook doesnt think we finished in error
    t)

  (defun org-clocking-luxafor-clock-in ()
    (org-clocking-luxafor-change-pattern org-clocking-luxafor-clock-in-pattern)
    ;; Return true, so the hook doesnt think we finished in error
    t)

  (defun org-clocking-luxafor-clock-out ()
    (org-clocking-luxafor-change-pattern org-clocking-luxafor-clock-out-pattern)
    ;; Return true, so the hook doesnt think we finished in error
    t)

  (defun org-clocking-luxafor-break-over ()
    (org-clocking-luxafor-change-pattern org-clocking-luxafor-break-really-over-pattern)
    (org-clocking-luxafor-change-pattern org-clocking-luxafor-break-over-pattern)
    ;; Return true, so the hook doesnt think we finished in error
    t)

  (add-hook 'org-pomodoro-killed-hook #'org-clocking-luxafor-off)
  (add-hook 'org-pomodoro-started-hook #'org-clocking-luxafor-clock-in)
  ;;(add-hook 'org-pomodoro-overtime-hook #'org-clocking-luxafor-clock-in)
  (add-hook 'org-pomodoro-finished-hook #'org-clocking-luxafor-clock-out)
  (add-hook 'org-pomodoro-break-finished-hook #'org-clocking-luxafor-break-over)

  ;; (defvar org-pomodoro-long-break-finished-hook nil
  ;; (defvar org-pomodoro-short-break-finished-hook nil
  ;; (defvar org-pomodoro-tick-hook nil
#+END_SRC

** =org-capture= templates
#+begin_src emacs-lisp :tangle yes
  (setq
   org-capture-templates
   '(
     ("t" "Todo [inbox]" entry ; New inbox item to be processed
      (file+headline jallen-org-gtd-file "Inbox")
      "* TODO %?\n %i\n\n")
     ("T" "Tickler" entry
      (file+headline jallen-org-gtd-file "Tickler")
      "* TODO %i%? \n SCHEDULED: <%(org-read-date nil nil \"+1d\")>")
     ("." "Do Task Now [inbox]" entry ; New inbox item to be processed
      (file+headline jallen-org-gtd-file "Tasks")
      "** NEXT %? \n  SCHEDULED: <%<%Y-%m-%d %H:%M>>\n %i\n\n")

     ("j" "Journal Entries")
     ("jm" "Precious Memory" entry ; Freeform journal entry
      (file+datetree jallen-org-journal-file)
      "* %? :memory:\n  %i\n  %a")
     ("jl" "Today I Learned" entry ; Breif TIL journal entry
      (file+datetree jallen-org-journal-file "TIL")
      "* %?\nLearned on %U :til:\n  %i\n  %a")
     ("j." "Journal" entry ; Freeform journal entry
      (file+datetree jallen-org-journal-file)
      "* %?\nEntered on %U\n  %i\n  %a")

     ("5" "5 Minute Journal")
     ("5m" "Morning Entry" entry (file+datetree jallen-org-5-min-journal-file)
      "* Morning\n  I am grateful for...\n  - %?\n  - \n  - \n\n  What will I do to make today great?\n  - \n  - \n  - \n\n  I am ...")
     ("5e" "Evening Entry" entry (file+datetree jallen-org-5-min-journal-file)
      "* Evening\n  3 amazing things that happened today...\n  - %?\n  - \n  - \n\n  How could I have made today even better?\n  - \n")

     ("f" "Food")
     ("fb" "Breakfast" entry (file+datetree jallen-org-diet-journal-file)
      "* Breakfast\n %U %?")
     ("fl" "Lunch" entry (file+datetree jallen-org-diet-journal-file)
      "* Lunch\n %U %?")
     ("fd" "Dinner" entry (file+datetree jallen-org-diet-journal-file)
      "* Dinner\n %U %?")
     ("fs" "Snack" entry (file+datetree jallen-org-diet-journal-file)
      "* Snack\n %U %?")

     ("w" "Weekly Report" item (file+olp+datetree jallen-org-weekly-report-file)
      "- %?%i\n" :tree-type week)

     ("n" "notes" entry ; Generic notebook entry
      (file+datetree jallen-org-notes-file)
      "* %? %U\n")
     ))
 #+end_src
** Habits
#+begin_src emacs-lisp :tangle yes
  (require 'org-habit)
  (setq org-habit-preceding-days 14
        org-habit-following-days 1
        org-habit-show-habits-only-for-today t
        org-habit-graph-column 52
        org-habit-show-all-today nil)
#+end_src
** Auto habit tracking for 5-min-journal et al.
   The ids in here are hardcoded the the random ids in my habits.org
  #+begin_src emacs-lisp :tangle yes
    (defun jallen/habit-id-checkoff (id)
      "Mark the habit with id as DONE"
      (save-excursion
        (org-id-goto id)
        (org-todo "DONE")))

    (defun jallen/complete-on-capture ()
      "To be run in org-capture-before-finalize-hook"
      (pcase (plist-get org-capture-current-plist :description)
        ("Morning Entry" (jallen/habit-id-checkoff "FEE1A918-0FFE-446F-A954-5B7A6DE29D3F"))
        ("Breakfast" (jallen/habit-id-checkoff "04E10333-848C-4328-B029-96AFDEEB9728"))
        ("Lunch" (jallen/habit-id-checkoff "88A42399-6041-4F0B-8255-17301AC69F74"))
        ("Dinner" (jallen/habit-id-checkoff "D4CFC543-13A6-40C3-A82F-880191F60CF5"))
        ("Evening Entry" (jallen/habit-id-checkoff "81125689-466F-4C87-9898-FB344CDD175F"))
        ("Weekly Report" (jallen/habit-id-checkoff "2BFA322E-1B16-4C62-868F-92BEE62D091E"))
        (_ (message "Capture complete!"))))

    (add-hook
     'org-capture-before-finalize-hook
     'jallen/complete-on-capture)
  #+end_src
** Revert/Save around captures
#+BEGIN_SRC emacs-lisp :tangle yes

  ;; ;; Revert buffer before capture
  ;; (add-hook
  ;;  'org-capture-mode-hook
  ;;  (lambda () (message (buffer-name)) (revert-buffer)) ;

  ;; Save after capture
  (add-hook
   'org-capture-before-finalize-hook
   (lambda () (save-buffer)))

#+END_SRC
** Regenerate Dynamic Blocks on save
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'before-save-hook 'org-update-all-dblocks)
  (add-hook 'before-save-hook 'org-table-recalculate-buffer-tables)
#+END_SRC
** Exporting
*** Exporter Setup
#+begin_src emacs-lisp :tangle yes
  (setq
   org-export-html-style-include-scripts nil
   org-export-html-style-include-default nil
   org-export-backends '(ascii beamer html icalendar texinfo latex)
   org-publish-use-timestamps-flag nil)
#+end_src
*** HTML postamble
#+begin_src emacs-lisp :tangle yes
  (setq org-html-postamble-format
        (quote
         (("en" "<p class=\"author\">Author: %a (%e)</p>
  powered by <p class=\"creator\">%c</p><p class=\"validation\">%v</p>"))))
#+end_src

** org-protocol
   For some reason I need to explicitly require this. I thought it
   would be pulled in as an org-module.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-protocol)
#+END_SRC
** org-download
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-download
  :after org
  :bind
  (:map org-mode-map
        (("s-Y" . org-download-screenshot)
         ("s-y" . org-download-yank))))
#+END_SRC
** org-roam
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-roam
    :ensure t
    :hook
    (after-init . org-roam-mode)
    (org-mode . company-mode)
    :custom
    (org-roam-directory (concat org-directory "roam"))
    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n g" . org-roam-graph-show))
                :map org-mode-map
                (("C-c n i" . org-roam-insert))
                (("C-c n I" . org-roam-insert-immediate))))

  (use-package org-roam-server
    :ensure t
    :config
    (setq org-roam-server-host "127.0.0.1"
          org-roam-server-port 5555
          org-roam-server-export-inline-images t
          org-roam-server-authenticate nil
          org-roam-server-label-truncate t
          org-roam-server-label-truncate-length 60
          org-roam-server-label-wrap-length 20))

  (use-package company-org-roam
    :config
    (push 'company-org-roam company-backends))

#+END_SRC
* Snippets
  Snippets are are awesome. They are found in ~/emacs.d/snippets
#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :diminish yas-minor-mode
  :config (yas-global-mode 1))
#+end_src

* Navigation
** Configure Windmove
   I like to use the S-<arrow> keys for moving windows
   #+begin_src emacs-lisp :tangle yes
     (windmove-default-keybindings)

     ;; Make windmove work in org-mode:
     (add-hook 'org-shiftup-final-hook 'windmove-up)
     (add-hook 'org-shiftleft-final-hook 'windmove-left)
     (add-hook 'org-shiftdown-final-hook 'windmove-down)
     (add-hook 'org-shiftright-final-hook 'windmove-right)

     (define-key org-mode-map (kbd "C-c <left>") (lambda () (interactive) (org-todo 'left)))
     (define-key org-mode-map (kbd "C-c <right>") (lambda () (interactive) (org-todo 'right)))

     ;; disable header todo cycling and just do windmove
     (defun jallen-org-header-windmove-right ()
       (if (and (not (eq org-support-shift-select 'always))
                (org-at-heading-p))
           (windmove-right)))
     (defun jallen-org-header-windmove-left ()
       (if (and (not (eq org-support-shift-select 'always))
                (org-at-heading-p))
           (windmove-left)))

     (add-hook 'org-shiftright-hook
               #'jallen-org-header-windmove-right)
     (add-hook 'org-shiftleft-hook
               #'jallen-org-header-windmove-left)
   #+end_src

** Manipulate Window Sizes
   C-x <arrow>
#+begin_src emacs-lisp :tangle yes
(global-set-key
 (kbd "C-x <right>")
 '(lambda () (interactive) (enlarge-window-horizontally 4)))
(global-set-key
 (kbd "C-x <left>")
 '(lambda () (interactive) (shrink-window-horizontally 4)))
(global-set-key
 (kbd "C-x <up>")
 '(lambda () (interactive) (enlarge-window 4)))
(global-set-key
 (kbd "C-x <down>")
 '(lambda () (interactive) (shrink-window 4)))
#+end_src
** Popwin
  Popwin give us special temporary behavior for certain buffers. This
  lets them pop in and out in a way that I like better than the
  default behavior of taking over the other-buffer

#+begin_src emacs-lisp :tangle yes
  (use-package popwin
    :config
    (progn
      (setq popwin:special-display-config nil)
      (push '("*Ibuffer*"
              :dedicated t :position top    :stick t :noselect t   :height 30)
            popwin:special-display-config)
      (push '("*Backtrace*"
              :dedicated t :position bottom :stick t :noselect nil :height 0.33)
            popwin:special-display-config)
      (push '("*compilation*"
              :dedicated t :position bottom :stick t :noselect t   :height 0.2)
            popwin:special-display-config)
      (push '("*Compile-Log*"
              :dedicated t :position bottom :stick t :noselect t   :height 0.33)
            popwin:special-display-config)
      (push '("*Help*"
              :dedicated t :position bottom :stick t :noselect nil :height 0.33)
            popwin:special-display-config)
      (push '("*Shell Command Output*"
              :dedicated t :position bottom :stick t :noselect nil :height 0.33)
            popwin:special-display-config)
      (push '(" *undo-tree*"
              :dedicated t :position bottom :stick t :noselect nil :height 0.33)
            popwin:special-display-config)
      (push '("*Warnings*"
              :dedicated t :position bottom :stick t :noselect nil :height 0.33)
            popwin:special-display-config)
      (push '("^\\*Man .*\\*$"
              :regexp t    :position bottom :stick t :noselect nil :height 0.33)
            popwin:special-display-config)
      (popwin-mode 1)))


  ;; (setq popwin:special-display-config
  ;;     (quote
  ;;      (("*Ibuffer*" :position top :noselect t :height 30)
  ;;       ("*Python Check*" :position top :noselect t :height 30)
  ;;       ("*compilation*")
  ;;       ("*Python Doc*")
  ;;       ("*xref*")
  ;;       ("*grep*")
  ;;       ("*Help*")
  ;;       ("*Completions*" :noselect t)
  ;;       ("*Occur*" :noselect t)))))
#+end_src

** Go to a line by number
   I'm not really sure why this isn't bound somewhere already... I use
   this all the time. Am I the weird one?
#+begin_src emacs-lisp :tangle yes
; (global-set-key (kbd "C-c t")  'goto-line)
#+end_src
** Enable win-switch
Super nice to switch between frames and buffers
#+begin_src emacs-lisp :tangle yes
  (use-package win-switch
    :bind (("C-x o" . win-switch-dispatch))
    :config
    (setq win-switch-provide-visual-feedback t)
    (setq win-switch-feedback-background-color "purple")
    (setq win-switch-feedback-foreground-color "white")
    (win-switch-setup-keys-default))
#+end_src
** Enable ibuffer
#+begin_src emacs-lisp :tangle yes
(use-package ibuffer-vc)
(use-package ibuffer-git)
(define-key global-map (kbd "C-x C-b") 'ibuffer)
(setq ibuffer-default-sorting-mode 'major-mode)
;; (define-key
;;   ibuffer-mode-map
;;   (kbd "RET")
;;   'ibuffer-visit-buffer-other-window)

#+end_src
** Enable =anzu=

I keep forgetting what anzu is... but i think I like it

#+begin_src emacs-lisp :tangle yes
(use-package anzu
  :config (global-anzu-mode +1)
  (setq anzu-mode-lighter ""))
#+end_src

** Save Point Positions Between Sessions
#+begin_src emacs-lisp :tangle yes
(use-package saveplace
  :config
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" "~/tmp/saves")))
#+end_src
** narrow/widen

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
    Dwim means: region, org-src-block, org-subtree, or
    defun, whichever applies first. Narrowing to
    org-src-block actually calls `org-edit-src-code'.

    With prefix P, don't widen, just narrow even if buffer
    is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  (define-key endless/toggle-map "n"
    #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing
  ;; keymap, that's how much I like this command. Only
  ;; copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map "\C-xn"
                nil)))

  (defun jallen-org-src-save-or-close () (interactive)
         (indent-region (point-min) (point-max))
         (if (buffer-modified-p)
             (save-buffer)
           (org-edit-src-exit)))

  (eval-after-load 'org-src
    '(define-key org-src-mode-map
       "\C-x\C-s" #'jallen-org-src-save-or-close))
#+END_SRC
** expand-region
   it's awsome
   #+begin_src emacs-lisp :tangle yes
     (use-package expand-region
       :commands er/expand-region
       :bind ("C-=" . er/expand-region))
   #+end_src
* Appearance
** Frame Titles
#+begin_src emacs-lisp :tangle yes
(setq frame-title-format (concat  "%b - emacs@" system-name))
#+end_src
** Fonts
 Install fonts from my .emacs.d into system locations
#+begin_src emacs-lisp :tangle yes
  (defun jallen-install-font ()
    "copy my font files into the system-specific location"
    (let ((fonts-source "~/.emacs.d/Input_Fonts/"))
      (if (string-equal system-type "darwin")
          (copy-directory fonts-source "~/Library/Fonts/") ; Mac
        (copy-directory fonts-source "~/.fonts/") ; Linux
        )
      ))

  (add-hook 'before-make-frame-hook
            (lambda ()
              (if (-any '(lambda (fonts) (string-prefix-p "-*-Input " (elt fonts 6))) (x-family-fonts))
                  (jallen-install-font))))
#+end_src

Define some shortcuts for sizes that I use sometimes
#+begin_src emacs-lisp :tangle yes
  (defun jallen-font () (interactive)
         (set-frame-font "Input Mono Narrow-16"))
  (defun jallen-font-no-contacts () (interactive)
         (set-frame-font "Input Mono Narrow-22"))
  (defun jallen-blind () (interactive)
         (set-frame-font "Input Mono Narrow-30"))
#+end_src


** Frame Configuration
#+begin_src emacs-lisp :tangle yes
(setq default-frame-alist
      (quote
       ((left-fringe . 1)
        (right-fringe . 1)
        (menu-bar-lines . 0)
        (tool-bar-lines . 0)
        (font . "Input Mono Narrow-16")
        )))
#+end_src
** Theme
   I love tangotango
#+begin_src emacs-lisp :tangle yes
(use-package tangotango-theme
  :config (load-theme 'tangotango t))
#+end_src
** Uniqify Buffer Names
   TODO make this lazy load maybe?
#+begin_src emacs-lisp :tangle yes
(require 'uniquify)
(setq uniquify-buffer-name-style 'reverse
      uniquify-separator "|"
      uniquify-after-kill-buffer-p t
      uniquify-ignore-buffers-re "^\\*")
#+end_src
** isearch faces
#+begin_src emacs-lisp :tangle yes
  (set-face-foreground 'lazy-highlight "black")
  (set-face-background 'lazy-highlight "yellow")
  (set-face-foreground 'isearch "white")
  (set-face-background 'isearch "blue")
#+end_src
** Turn off nux and noisy UI
   No scroll, tool, menu bars
#+begin_src emacs-lisp :tangle yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+end_src

   Scratch buffer can just be empty, thanks
#+begin_src emacs-lisp :tangle yes
  (setq initial-scratch-message nil)
#+end_src

   No NUX
#+begin_src emacs-lisp :tangle yes
  (setq inhibit-splash-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+end_src

** Show lines and columns
#+begin_src emacs-lisp :tangle yes
(setq line-number-mode t
      column-number-mode t)
#+end_src
** Highlight the selected region
#+begin_src emacs-lisp :tangle yes
(setq transient-mark-mode t)
#+end_src
* Terminal Configuration
** Fix my shell prompt regex
   I use fancy unicode characters in my shell prompt

** Terminals in emacs should use ansi colors
#+begin_src emacs-lisp :tangle yes
(use-package ansi-color)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
(setq comint-prompt-read-only t)
#+end_src

** Deal with running emacs in terminal
   Here is some scar tissue of me trying to make all keys work in the
terminal as they do in X11. This isn't possible as far as I can tell,
and I'm no longer sure if this does anything for me.

we are expecting an xterm compatible terminal here. tmux requires you
to set xterm-mode as a terminal option for this

#+begin_src emacs-lisp :tangle yes
(defadvice terminal-init-xterm (after map-S-up-escape-sequence activate)
  (define-key input-decode-map "\e[1;9A" [M-up])
  (define-key input-decode-map "\e[1;9B" [M-down])
  (define-key input-decode-map "\e[1;9C" [M-right])
  (define-key input-decode-map "\e[1;9D" [M-left])

  (define-key input-decode-map "\e[1;10A" [M-S-up])
  (define-key input-decode-map "\e[1;10B" [M-S-down])
  (define-key input-decode-map "\e[1;10C" [M-S-right])
  (define-key input-decode-map "\e[1;10D" [M-S-left])

  ;; weird
  (global-set-key [select] [S-up])
)

#+end_src

* Weather
  Because weather
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package wttrin
      :ensure t
      :commands (wttrin)
      :init
      (setq wttrin-default-cities '("New York" "Sag Harbor, NY")
            wttrin-default-accept-language '("Accept-Language" . "en-US")))
    (define-key ctl-x-map "w" 'wttrin)
  #+END_SRC
* Dired
** Enable =dired-x=
#+begin_src emacs-lisp :tangle yes
(require 'dired-x)
#+end_src

** Simple =dired= display
#+begin_src emacs-lisp :tangle yes
; (use-package dired-details
;   :config
;   (setq-default dired-details-hidden-string "--- ")
;   (dired-details-install))
#+end_src
* Disable warnings about large files
  I'm not afraid of large files, yo

#+begin_src emacs-lisp :tangle yes
(setq large-file-warning-threshold nil)
#+end_src
* Search/Match should be case insensitive
  The documentation is actually a little misleading. The search will
  be case sensitive if the search string has any capital characters in
  it.
#+begin_src emacs-lisp :tangle yes
(setq case-fold-search t)
#+end_src
* Revert Files When They Change On Disk
#+begin_src emacs-lisp :tangle yes
  (global-auto-revert-mode t)
#+end_src
* Simple Behavior Customizations
** Set fill-column to sensible default for me
#+begin_src emacs-lisp :tangle yes
(setq fill-column 78)
#+end_src
** Backups
#+begin_src emacs-lisp :tangle yes
(defvar user-temporary-file-directory "~/tmp/saves/"
  (concat temporary-file-directory user-login-name "/"))
(make-directory user-temporary-file-directory t)

(setq
 make-backup-files t
 backup-by-copying t      ; don't clobber symlinks
 backup-directory-alist
 '(("." . user-temporary-file-directory))    ; don't litter my fs tree
 delete-old-versions t
 kept-new-versions 6
 kept-old-versions 2
 version-control t)       ; use versioned backups

; disable vc integration, the repos can just be too big
(setq vc-handled-backends nil)
(setq vc-make-backup-files t)

(setq backup-directory-alist
      `((".*" . ,user-temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,user-temporary-file-directory t)))
(setq auto-save-list-file-prefix
      (concat user-temporary-file-directory ".auto-saves-"))

#+end_src

** Text-mode is a better default than fundamental for me
#+begin_src emacs-lisp :tangle yes
(setq-default major-mode 'text-mode)
#+end_src
** Replace 'yes/no' by just 'y/n'
#+begin_src emacs-lisp :tangle yes
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Tags operations should be case sensitive
#+begin_src emacs-lisp :tangle yes
(setq tags-case-fold-search nil)
#+end_src

** Smooth Scrolling
   https://www.emacswiki.org/emacs/SmoothScrolling
   #+begin_src emacs-lisp :tangle yes
   (setq scroll-step 1
         scroll-conservatively 10000
         mouse-wheel-scroll-amount '(1 ((shift) . 1))
         mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
         mouse-wheel-follow-mouse t) ;; scroll window under mouse
   #+end_src
** Screen Splitting
#+begin_src emacs-lisp :tangle yes
(setq split-height-threshold 10000
      split-width-threshold 10000)
#+end_src
** Subword movement in prog-mode
#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'subword-mode)
#+end_src
** No bell, thanks
#+begin_src emacs-lisp :tangle yes
(setq ring-bell-function 'ignore)
#+end_src
* Spellcheck in Comments & Strings
#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src
* Editing
** Multiple Cursors                                                             :today:
   Multi-cursor editing is so cool when you can do it. Useful when
   editing many similar lines. More interactive than macros.
#+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind (("M-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)
         ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+end_src

** Align lines on ' = '
#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-c =") 'align-eq)
#+end_src
** Revert a buffer
#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+end_src
** Unfill paragraphs
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (global-set-key (kbd "M-Q") 'unfill-paragraph)
#+END_SRC
* VC

** git-gutter-mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package git-gutter
     :diminish git-gutter-mode
     :commands (git-gutter-mode)
     :bind (:map vc-prefix-map
                 ("[" . git-gutter:previous-hunk)
                 ("]" . git-gutter:next-hunk)
                 ("n" . git-gutter:revert-hunk)
                 ("SPC" . git-gutter:mark-hunk))
     :init
     (global-git-gutter-mode)
     :config
     (setq git-gutter:handled-backends '(git hg)))

  ;; vc-hg comes with emacs, but we can still use use-package to group related
  ;; config

  (use-package vc-hg
    :ensure nil
    :bind
    (:map vc-prefix-map
          ("a" . vc-annotate)
          ;; 'g' is the original binding for vc-annotate
          ("g" . nil))
    :config
    (setq
     vc-hg-annotate-re
     (concat
      "^\\(?: *[^ ]+ +\\)?\\(D?[0-9]+\\) +" ;; user and revision
      "\\([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]\\)" ;; date
      "\\(?: +\\([^:]+\\)\\)?:") ;; filename
     vc-annotate-hg-switches "-u"
     )
    ;; redefine vc-hg-annotate-command to use -p (phabricator diff) instead of -n
    ;; (revision number)
    ;; TODO select -p or -n base on whether or not the hg repo is a phabricator
    ;; project. Is there a better way to do this other than replacing the
    ;; function, e.g. with advice?
    (defun vc-hg-annotate-command (file buffer &optional revision)
      "Execute \"hg annotate\" on FILE, inserting the contents in BUFFER.
   Optional arg REVISION is a revision to annotate from."
      (apply #'vc-hg-command buffer 0 file "annotate" "-dq" "-p"
             (append (vc-switches 'hg 'annotate)
                     (if revision (list (concat "-r" revision)))))))
#+END_SRC

* Flycheck

#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :diminish
    :config
    (setq-default flycheck-temp-prefix ".flycheck")
    (setq-default flycheck-disabled-checkers
                  '(emacs-lisp-checkdoc
                    python-flake8
                    json-jsonlist)))
#+end_src

* Awesome Key Bindings
** Multiple Cursors
#+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind
  (("M-c" . mc/edit-lines)
   ("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-c C-<" . mc/mark-all-like-this)))
#+end_src

* Utility Functions
** Read lines of file into a list
#+begin_src emacs-lisp :tangle yes
(defun jallen-read-lines (fpath)
  "Return a list of lines of a file at at FPATH."
  (with-temp-buffer
    (insert-file-contents fpath)
    (split-string (buffer-string) "\n" t)))
#+end_src
** Edit Current Buffer As root
#+begin_src emacs-lisp :tangle yes
(defun sudo ()
  "Use TRAMP to `sudo' the current buffer"
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+end_src
** Sort Lines In Paragraph
#+begin_src emacs-lisp :tangle yes
(defun jallen-sort-para ()
  "Sorts the paragraph in which the point is located"
  (interactive)
  (save-excursion
    (let (bpoint epoint)
      (backward-paragraph)
      (setq bpoint (point))
      (forward-paragraph)
      (setq epoint (point))
      (sort-lines nil bpoint epoint)
      )
    ))
#+end_src
** Increment/Decrement number at point
   Because why not?
#+begin_src emacs-lisp :tangle yes
(defun increment-number-at-point ()
  (interactive)
  (skip-chars-backward "0-9")
  (or (looking-at "[0-9]+")
      (error "No number at point"))
  (replace-match (number-to-string (1+ (string-to-number (match-string 0))))))

(defun decrement-number-at-point ()
  (interactive)
  (skip-chars-backward "0-9")
  (or (looking-at "[0-9]+")
      (error "No number at point"))
  (replace-match (number-to-string (- (string-to-number (match-string 0)) 1))))
#+end_src
* Compilation
  If I'm compiling, just save all the buffers automatically for me
#+begin_src emacs-lisp :tangle yes
(setq compilation-ask-about-save nil)
#+end_src
  And make some nice hotkeys
#+BEGIN_SRC emacs-lisp tangle: yes
  (global-set-key (kbd "<f6>") 'compile)
  (global-set-key (kbd "<f7>") 'next-error) ;; can make this not global
#+END_SRC
** BUCK
#+BEGIN_SRC emacs-lisp tangle: yes
  (require 'cl)

  (defun buck--absolute-directory-path (path)
    "Given a file name, returns the buck path to its directory."
    (concat "//"
            (directory-file-name
             (file-name-directory
              (file-relative-name
               path (locate-dominating-file path ".buckconfig"))))))

  (defun buck--find-targets-in-targets-file (targets-file)
    "Given a TARGETS file, returns all targets defined in it."
    (split-string
     (shell-command-to-string
      ; We could use `buck query' here, but this is much faster, though
      ; less precise.
      ; We can also consider adding `...' and `all' targets.
      (format "grep 'name = ' %s | cut -d\\\" -f2" targets-file))
     "\n" t))

  (defun buck--find-tests-in-targets-file (targets-file)
    "Given a TARGETS file, returns all tests defined in it."
    (split-string
     (shell-command-to-string
      ; Again, `buck query' would be more accurate.
      (format "grep -A 1 '^[a-z_]*test' %s | grep 'name = ' | cut -d\\\" -f2"
              targets-file))
     "\n" t))

  (defun buck--find-fully-qualified-targets-in-targets-file (targets-file
                                                             finder)
    "Given a TARGETS file, return full buck paths to all its targets.

  `finder' is a function that, given a TARGETS file, determines
  its targets, e.g. `buck--find-targets-in-targets-file'."
    (let ((base (buck--absolute-directory-path targets-file)))
      (mapcar
       (lambda (target) (format "%s:%s" base target))
       (apply finder targets-file nil))))

  (defun buck--find-targets-files-under (dir)
    "Returns the full path of all TARGETS files under `dir'."
    (mapcar
     (lambda (target) target)
     (split-string
      (shell-command-to-string (format "find %s -name TARGETS" dir))
      "\n" t)))

  (defun buck--find-all-targets-under (dir finder)
    "Returns all buck targets at or below `dir'.

  `finder' is a function that, given a TARGETS file, determines
  its targets, e.g. `buck--find-targets-in-targets-file'."
    (cl-mapcan
     (lambda (targets-file)
       (buck--find-fully-qualified-targets-in-targets-file targets-file finder))
     (buck--find-targets-files-under dir)))

  (defun buck--find-build-targets-under (dir)
    "Returns all buildable buck targets at or below `dir'."
    (buck--find-all-targets-under dir 'buck--find-targets-in-targets-file))

  (defun buck--find-test-targets-under (dir)
    "Returns all testable buck targets at or below `dir'."
    (buck--find-all-targets-under dir 'buck--find-tests-in-targets-file))

  (defun buck--my-target-name ()
    "Returns a guess at the target name for the current file."
    (concat (buck--absolute-directory-path (buffer-file-name)) ":"
            (string-trim
             (shell-command-to-string
              (format "grep -Pzo '(?s)name = [^)]*\"%s\"' %sTARGETS | head -1 | cut -d\\\" -f2"
                      (file-name-nondirectory (buffer-file-name))
                      (file-name-directory (buffer-file-name)))))))

  (defvar buck--build-target-history nil "History for buck-build.")
  (defvar buck--test-target-history nil "History for buck-test.")

  (defun buck-build ()
    "Choose and build a target with buck."
    (interactive)
    (compile
     (format
      "buck build --report-absolute-paths %s"
      (completing-read
       "Build target: "
       (buck--find-build-targets-under default-directory)
       nil 'confirm (buck--my-target-name) 'buck--build-target-history))))

  (defun buck-test ()
    "Choose and test a target with buck."
    (interactive)
    (compile
     (format
      "buck test --report-absolute-paths %s"
      (completing-read
       "Test target: "
       (buck--find-test-targets-under default-directory)
       nil 'confirm nil 'buck--test-target-history))))

  (global-set-key (kbd "<f5>") 'buck-build)
  (global-set-key (kbd "<f8>") 'buck-test)

  (defun bcp--update-modeline ()
    (save-excursion
      (if (re-search-backward "^BUILT \\([[:digit:]]+\\)/\\([[:digit:]]+\\) "
                              compilation-filter-start t)
          (progn
            (let ((num (string-to-number (match-string 1)))
                  (denom (string-to-number (match-string 2))))
              (setq-local mode-line-process
                          (format ":%d%% (%d/%d)"
                                  (/ (* 100 num) denom)
                                  num denom)))))))

  (add-hook 'compilation-filter-hook 'bcp--update-modeline)
#+END_SRC
* Code Format
  :LOGBOOK:
  - State "MAYBE"      from "TODO"       [2019-02-13 Wed 10:37]
  :END:
** Default Indentation
   c-basic-offset is used by most major modes I use as the basis for
   how deeply to indent any code.
#+begin_src emacs-lisp :tangle yes
(setq c-basic-offset 2)
#+end_src
** Whitespace
  I don't highlight trailing whitespace, because I auto-kill it anyway
#+begin_src emacs-lisp :tangle yes
(setq-default show-trailing-whitespace nil)
#+end_src
  And here we do the killing
#+begin_src emacs-lisp :tangle yes
(add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src
** Tabs
#+begin_src emacs-lisp :tangle yes
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
(setq tab-width 2)
#+end_src
** Add newline to the end of files
#+begin_src emacs-lisp :tangle yes
(setq require-final-newline t)
#+end_src
** Set Unix file coding system
#+begin_src emacs-lisp :tangle yes
(setq-default buffer-file-coding-system 'utf-8-unix)
(setq-default default-buffer-file-coding-system 'utf-8-unix)
(set-default-coding-systems 'utf-8-unix)
(prefer-coding-system 'utf-8-unix)
#+end_src
* Better regex-builder
  'string' does not require the crazy double escape thing from emacs
  regexes
#+begin_src emacs-lisp :tangle yes
(use-package re-builder
  :config
  (setq reb-re-syntax 'string))
#+end_src
* Make scripts executable on save
#+begin_src emacs-lisp :tangle yes
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src
* echo-keys
  This is useful for screen capture videos
  #+begin_src emacs-lisp :tangle yes
    (defvar *echo-keys-last* nil "Last command processed by `echo-keys'.")

    (defun echo-keys ()
      (interactive)
      (let ((deactivate-mark deactivate-mark))
        (when (this-command-keys)
          (with-current-buffer (get-buffer-create "*echo-key*")
            (goto-char (point-max))
            ;; self  self
            ;; self  other \n
            ;; other self  \n
            ;; other other \n
            (unless (and (eq 'self-insert-command *echo-keys-last*)
                         (eq 'self-insert-command this-command))
              (insert "\n"))
            (if (eql this-command 'self-insert-command)
                (let ((desc (key-description (this-command-keys))))
                  (if (= 1 (length desc))
                      (insert desc)
                    (insert " " desc " ")))
              (insert (key-description (this-command-keys))))
            (setf *echo-keys-last* this-command)
            (dolist (window (window-list))
              (when (eq (window-buffer window) (current-buffer))
                ;; We need to use both to get the effect.
                (set-window-point window (point))
                (end-of-buffer)))))))

    (defun toggle-echo-keys ()
      (interactive)
      (if (member 'echo-keys  pre-command-hook)
          (progn
            (remove-hook 'pre-command-hook 'echo-keys)
            (dolist (window (window-list))
              (when (eq (window-buffer window) (get-buffer "*echo-key*"))
                (delete-window window))))
        (progn
          (add-hook    'pre-command-hook 'echo-keys)
          (delete-other-windows)
          (split-window nil (- (window-width) 32) t)
          (other-window 1)
          (switch-to-buffer (get-buffer-create "*echo-key*"))
          (set-window-dedicated-p (selected-window) t)
          (other-window 1))))
  #+end_src
* LSP
** TODO Basic
   move xref stuff to a general xref section
#+BEGIN_SRC emacs-lisp tangle: yes

  (use-package lsp-mode
    :config
    (setq
     lsp-ui-sideline-show-code-actions nil
     lsp-ui-sideline-show-hover nil
     lsp-highlight-symbol-at-point nil))

  (use-package company-lsp
    :after (lsp-mode company-mode)
    :config
    (push 'company-lsp company-backends)
    (setq company-lsp-enable-snippet t
          company-lsp-cache-candidates t))

  (use-package lsp-ui :commands lsp-ui-mode)

#+END_SRC

** cquery
#+BEGIN_SRC emacs-lisp tangle: yes
  ;; (use-package cquery
  ;;   :if
  ;;   (file-exists-p "/bin/cquery")
  ;;   :bind
  ;;   (:map c-mode-base-map
  ;;     ("M-." . xref-find-definitions)
  ;;     ("C-t h c" . cquery-call-hierarchy)
  ;;     ("C-t h i" . cquery-inheritance-hierarchy)
  ;;     ("C-t i" . lsp-ui-sideline-toggle-symbols-info)
  ;;     ("C-t I". helm-imenu)
  ;;     ("C-t h m" . cquery-member-hierarchy)
  ;;     ("C-t ." . lsp-ui-peek-find-definitions)
  ;;     ("C-t ?" . lsp-ui-peek-find-references))
  ;;   :preface
  ;;   (defun cquery//enable ()
  ;;     (condition-case nil
  ;;       (lsp-cquery-enable)
  ;;       (user-error nil)))
  ;;   :init
  ;;   (add-hook 'c-mode-common-hook #'cquery//enable)
  ;;   :config
  ;;   (setq cquery-executable "/bin/cquery"
  ;;         cquery-extra-args '("--log-file=/tmp/cq.log")
  ;;         cquery-extra-init-params '(:completion (:detailedLabel t))
  ;;         cquery-sem-highlight-method 'font-lock))
#+END_SRC
* Hideshow

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'hideshow)
  (define-key hs-minor-mode-map "\C-\M-i" 'hs-toggle-hiding) ;; C-tab
  (define-key hs-minor-mode-map "\C-\M-y" 'hs-show-all)      ;; C-S-tab
#+END_SRC
* Modes
** elisp
*** Turn on eldoc-mode
   #+begin_src emacs-lisp :tangle yes
   (use-package eldoc
     :diminish eldoc-mode
     :config (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
   #+end_src

*** Enable slime-nav
   #+begin_src emacs-lisp :tangle yes
     (use-package elisp-slime-nav
       :diminish elisp-slime-nav-mode
       :config
       (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t))))
   #+end_src
*** Enable =rainbow-delimiters=
    But only for emacs-lisp
    #+begin_src emacs-lisp :tangle yes
    (use-package rainbow-delimiters
      :config
      (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
    #+end_src

*** package-lint for authoring packages
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package package-lint)
#+END_SRC

** CSS
#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode :delight)
(use-package css-mode
  :mode "\\.css$"
  :config
  (setq css-indent-level 2
        css-indent-offset 2)
  (add-hook 'css-mode-hook 'rainbow-mode)
)
#+end_src
** C++

#+begin_src emacs-lisp :tangle yes
  (use-package modern-cpp-font-lock
    :ensure t)

  (use-package google-c-style
    :config
    (add-hook 'c-mode-common-hook 'google-set-c-style)
    (add-hook 'c-mode-common-hook 'google-make-newline-indent))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
  (define-key org-mode-map (kbd "C-c o") 'ff-get-other-file)
  (add-hook 'c++-mode-hook
            (lambda ()
              (subword-mode 1)
              (modern-c++-font-lock-mode)
              (setq-local require-final-newline t)
              (setq-local compilation-auto-jump-to-first-error t)))
#+end_src

** ediff

Add a special command line switch to emacs so that we can easily use
emacs as our diff tool.

#+BEGIN_SRC bash
emacs -diff file1 file2
#+END_SRC

#+begin_src emacs-lisp :tangle yes
(defun command-line-diff (switch)
  (let ((file1 (pop command-line-args-left))
        (file2 (pop command-line-args-left)))
    (ediff file1 file2)))

(add-to-list 'command-switch-alist '("diff" . command-line-diff))

(add-hook 'ediff-load-hook
          (lambda ()
            (message "getting my diff onnnnn")
            (flycheck-mode nil)
            (setq ediff-highlight-all-diffs nil)
            (set-face-background
             ediff-current-diff-face-A "#1e2424")
            (set-face-background
             ediff-current-diff-face-B "#1e2424")
            (set-face-background
             ediff-current-diff-face-C "#1e2424")
            (make-face-italic
             ediff-current-diff-face-A)
            (make-face-italic
             ediff-current-diff-face-B)
            (make-face-italic
             ediff-current-diff-face-C)))
#+end_src
** YAML
   Enable =yaml-mode=
#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
  :mode ("\\.yml$" "\\.yaml$" "\\.lock$")
  :config
  (add-hook 'yaml-mode-hook 'flycheck-mode)
  (add-hook 'yaml-mode-hook 'flyspell-mode))
#+end_src
** Python
   In the past I've used elpy to great effect, but I haven't messed
   with that in a while
*** BUCK/TARGETS
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\/TARGETS\\'" . python-mode))
(add-to-list 'auto-mode-alist '("\\/BUCK\\'" . python-mode))
#+END_SRC
*** Setup =python-mode=
   #+begin_src emacs-lisp :tangle yes
   ;; (add-hook 'python-mode-hook 'lsp)
   (setq python-shell-interpreter "/usr/bin/ipython")
   (setq py-basic-offset 4)
   #+end_src
*** Enable company-jedi
   #+begin_src emacs-lisp :tangle yes
                                             ; (use-package company-jedi
                                             ;   :config (add-to-list 'company-backends 'company-jedi))
   #+end_src
** Thrift
 #+begin_src emacs-lisp :tangle yes
   (use-package thrift)
#+end_src
** JSON
  #+begin_src emacs-lisp :tangle yes
    (use-package json)
  #+end_src

** Markdown
  #+begin_src emacs-lisp :tangle yes
    (use-package markdown-mode
       :mode (("\\.text\\'" . markdown-mode)
              ("\\.markdown\\'" . markdown-mode)
              ("README\\.md\\'" . gfm-mode)))
  #+end_src

** Hack

#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package hack-mode
    :init
    (add-hook 'hack-mode-hook
              (lambda ()
                (lsp)
                (flycheck-mode t)
                (subword-mode t)
                (company-mode t)
                )))
#+END_SRC

** JS + Web
   Web mode is a very, very, very fine mode
   #+begin_src emacs-lisp :tangle yes
     (use-package js-comint)
     (use-package web-mode
       :mode "\\.phtml\\'"
       :mode "\\.[agj]sp\\'"
       :mode "\\.as[cp]x\\'"
       :mode "\\.erb\\'"
       :mode "\\.mustache\\'"
       :mode "\\.djhtml\\'"
       :mode "\\.html?\\'"
       :mode "\\.jsx?\\'"
       :bind
       (:map web-mode-map
             ("C-x C-e" . js-send-last-sexp)
             ("C-M-x" . js-send-last-sexp-and-go)
             ("C-c b" . js-send-buffer)
             ("C-c C-b" . js-send-buffer-and-go)
             ("C-c l" . js-load-file-and-go)
             )
       :config
       (setq web-mode-code-indent-offset 2
             web-mode-css-indent-offset 2
             web-mode-attr-indent-offset 2
             web-mode-enable-auto-closing t
             web-mode-enable-auto-indentation t
             web-mode-enable-auto-opening t
             web-mode-enable-auto-pairing t
             web-mode-enable-auto-quoting t
             web-mode-markup-indent-offset 2
             web-mode-script-padding 2
             web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'"))
             web-mode-style-padding 2)
       (font-lock-add-keywords
        'web-mode `(("\\(function *\\)("
                     (0 (progn (compose-region (match-beginning 1) (match-end 1) "Æ")
                               nil)))))
       (setq-default flycheck-disabled-checkers
                     (append flycheck-disabled-checkers
                             '(javascript-jshint)))
       (flycheck-add-mode 'javascript-eslint 'web-mode)
       (defadvice web-mode-highlight-part (around tweak-jsx activate)
         (if (equal web-mode-content-type "jsx")
             (let ((web-mode-enable-part-face nil))
               ad-do-it)
           ad-do-it))
       (add-to-list 'web-mode-indentation-params '("lineup-calls" . nil))
       (add-to-list 'web-mode-indentation-params '("lineup-concats" . nil))
       (add-to-list 'web-mode-indentation-params '("lineup-ternary" . nil)))
   #+end_src
** Go
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package go-mode
       :defer t
       :ensure t
       :mode ("\\.go\\'" . go-mode)
       :init
       (setq compile-command "echo Building... && go build -v && echo Testing... && go test -v && echo Linter... && golint")
       (setq compilation-read-command nil)
       (add-hook 'go-mode-hook 'custom-go-mode)
       :bind (("M-," . compile)
              ("M-." . godef-jump)))
   #+END_SRC
** Config File Formats
  #+begin_src emacs-lisp :tangle yes
    (use-package gitignore-mode)
    (use-package gitconfig-mode)
    (use-package hgignore-mode)
    (use-package hgrc-mode)
  #+end_src
* Which Key was that again?

#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :pin gnu
    :diminish which-key-mode
    :config (which-key-mode 1))
#+end_src
* Log major-mode
  #+begin_src emacs-lisp :tangle yes
    (add-hook 'prog-mode-hook (lambda () (message "%s" major-mode)) 'append)
  #+end_src

* RSS Reader
** Basic setup
   #+begin_src emacs-lisp :tangle yes
     (setq newsticker-date-format "(%A %D %H:%M)"
           newsticker-html-renderer 'shr-render-region
           newsticker-use-full-width nil)
   #+end_src
** Set up HTML rendering
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package w3m
  ;;   :if (executable-find "w3m")
  ;;   :config
  ;;   (setq newsticker-html-renderer 'w3m-region))
 #+END_SRC
** List of blogs
#+begin_src emacs-lisp :tangle yes
    (global-set-key (kbd "C-c C-n") 'newsticker-show-news)
    (setq-default
     newsticker-url-list
     '(("Westside Rag" "https://www.westsiderag.com/feed" nil nil nil)
       ("Schneier on Security" "https://www.schneier.com/blog/atom.xml" nil nil nil)
       ("Xah Emacs Blog" "http://ergoemacs.org/emacs/blog.xml" nil nil nil)
       ("Arabesque" "https://sanctum.geek.nz/arabesque/feed/" nil nil nil)
       ("XKCD" "https://xkcd.com/rss.xml" nil nil nil)
       ("Sacha Chua" "http://sachachua.com/blog/feed/" nil nil nil)))
#+end_src
* Scratch
** lsp-thrift

#+BEGIN_SRC emacs-lisp :tangle yes

    (require 'lsp-mode)

    (defgroup lsp-thrift nil
      "Thrift."
      :group 'lsp-mode
      :tag "Thrift")

    (defcustom lsp-thrift-command '("/usr/local/bin/thrift-lsp")
      "thrift-lsp command."
      :group 'lsp-thrift
      :risky t
      :type 'list)

    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection (lambda () lsp-thrift-command))
                      :major-modes '(thrift-mode)
                      :priority -1
                      :server-id 'thrift))

    (setq lsp-language-id-configuration
          (append lsp-language-id-configuration  '((thrift-mode . "thrift"))))

  (locate-dominating-file "/data/users/jallen/fbsource/fbcode/strobelight/if/service.thrift" "fbcode")

         ;; 'fbcode',
         ;; 'fbandroid',
         ;; 'fbobjc',
         ;; 'configerator-hg/source',
         ;; 'opsfiles-hg',
         ;; 'configerator-eden/source',
         ;; 'opsfiles-eden
#+END_SRC
