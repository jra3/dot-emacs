#+TITLE: Emacs Configuration
#+AUTHOR: John Allen
#+STARTUP: overview

* mac magic
#+BEGIN_SRC emacs-lisp tangle: yes
  ;; Keybonds
  (global-set-key [(hyper a)] 'mark-whole-buffer)
  (global-set-key [(hyper v)] 'yank)
  (global-set-key [(hyper c)] 'kill-ring-save)
  (global-set-key [(hyper s)] 'save-buffer)
  (global-set-key [(hyper l)] 'goto-line)
  (global-set-key [(hyper w)]
		  (lambda () (interactive) (delete-window)))
  (global-set-key [(hyper z)] 'undo)

  (setq mac-option-modifier 'meta)
  (setq mac-command-modifier 'hyper)

#+END_SRC

Mac tries to hide your $PATH from you when using a graphical mode

#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package exec-path-from-shell
  	:if (memq window-system '(mac ns))
  	:config
  	(exec-path-from-shell-initialize))
#+END_SRC

* Configure Helm
Make everything fuzzy and also rebind functions.
#+BEGIN_SRC python tangle: no
  (use-package flx)
  (use-package helm-flx)
  (use-package helm-descbinds)
  (use-package helm
   :demand
    :diminish helm-mode
    :bind (
     ("M-x" . helm-M-x)
     ("M-y" . helm-show-kill-ring)
     ("C-x b" . helm-mini)
     ("C-x C-f" . helm-find-files)
     ("C-x r l" . helm-bookmarks)
     ("C-c C-i" . helm-semantic-or-imenu)
     :map helm-find-files-map ;; I like these from Ido
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-<backspace>" . helm-find-files-up-one-level))
    :config
    (helm-mode 1)
    (helm-descbinds-mode)
    (helm-flx-mode +1)
    (setq helm-M-x-fuzzy-match t
    helm-buffers-fuzzy-matching t
    helm-recentf-fuzzy-match t
    helm-locate-fuzzy-match t
    helm-lisp-fuzzy-completion t
    helm-bookmark-show-location t))

  (use-package helm-xref
    :config
    (setq xref-show-xrefs-function 'helm-xref-show-xrefs))

#+END_SRC
* Configure Completions
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package vertico
    :ensure t
    :diminish vertico-mode
    :init
    (savehist-mode 1)
    :config
    (vertico-mode 1)
    (setq vertico-cycle t))

  (use-package marginalia
    :ensure t
    :after vertico
    :diminish marginalia-mode
    :config
    (marginalia-mode 1))

  (use-package consult
  	:ensure t
  	:bind (
  		("C-x b" . consult-buffer)
  		("C-s" . consult-line)
  		("M-o" . consult-find)
  		("M-l" . consult-goto-line)
  		("M-s l" . consult-locate)
  		("M-s g" . consult-git-grep)
  		("M-s s" . consult-ripgrep)
  		("C-x r l" . consult-bookmark)
  		("C-c C-i" . consult-imenu))
  :init
  (setq
   consult-locate-args "mdfind -name %s 2>/dev/null"
   xref-show-xrefs-function #'consult-xref
   xref-show-definitions-function #'consult-xref))

  (use-package orderless
      :ensure t
      :init
      (setq completion-styles '(orderless basic)
      completion-category-defaults nil
      completion-category-overrides '((file (styles partial-completion)))))

  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)         ;; pick some action on the current candidate
     ("C-;" . embark-dwim))       ;; "do what I mean" (contextual) action
    :init
    ;; Show Embark actions in the minibuffer-side window
    (setq embark-indicators '(embark-minimal-indicator embark-which-key-indicator))
    :config
    ;; Optionally, use which-key to display available actions
    (setq embark-which-key-prefix ","))

  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :config
    ;; If you want Embark actions to integrate with Consult previews:
    (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode))

#+END_SRC
* Customization File
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq custom-file (concat config-load-path "custom.el"))
  (load custom-file)
#+END_SRC

* Appearance
** Fonts
Install fonts from my .emacs.d into system locations
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun jallen-install-font ()
  	"copy my font files into the system-specific location"
  	(let ((fonts-source "~/.emacs.d/Input_Fonts/"))
  		(if (string-equal system-type "darwin")
	  (copy-directory fonts-source "~/Library/Fonts/") ; Mac
	(copy-directory fonts-source "~/.fonts/") ; Linux
	)
  		))

  (add-hook 'before-make-frame-hook
	    (lambda ()
	      (if (-any '(lambda (fonts) (string-prefix-p "-*-Input " (elt fonts 6))) (x-family-fonts))
		  (jallen-install-font))))

#+END_SRC

Define some shortcuts for sizes that I use sometimes
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun jallen-font () (interactive)
	 (set-frame-font "Input Mono Narrow-16"))
  (defun jallen-font-no-contacts () (interactive)
	 (set-frame-font "Input Mono Narrow-22"))
  (defun jallen-blind () (interactive)
	 (set-frame-font "Input Mono Narrow-30"))
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package tangotango-theme
		:ensure t
		:config
		(load-theme 'tangotango t))
#+END_SRC

isearch faces customizations
#+BEGIN_SRC emacs-lisp tangle: yes
	(set-face-foreground 'lazy-highlight "black")
	(set-face-background 'lazy-highlight "yellow")
	(set-face-foreground 'isearch "white")
	(set-face-background 'isearch "blue")
#+END_SRC

** Frame Settings

Titles
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq frame-title-format (concat  "%b - emacs@" system-name))
#+END_SRC

Frame Configuration
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq default-frame-alist
	(quote
	 ((left-fringe . 1)
	  (right-fringe . 1)
	  (menu-bar-lines . 0)
	  (tool-bar-lines . 0)
	  (font . "Input Mono Narrow-16")
	  )))
#+END_SRC

Uniqify Buffer Names
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package uniquify
    :ensure nil  ;; built-in
    :init
    (setq uniquify-buffer-name-style 'reverse
	  uniquify-separator "|"
	  uniquify-after-kill-buffer-p t
	  uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

Show lines and columns
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq line-number-mode t
	column-number-mode t)
#+END_SRC

Show number and ordinality of matching
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package anzu
	:config (global-anzu-mode +1)
	(setq anzu-mode-lighter ""))
#+END_SRC

Highlight the selected region
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq transient-mark-mode t)
#+END_SRC

https://www.emacswiki.org/emacs/SmoothScrolling
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq scroll-step 1
			scroll-conservatively 10000
			mouse-wheel-scroll-amount '(1 ((shift) . 1))
			mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
			mouse-wheel-follow-mouse t) ;; scroll window under mouse
#+END_SRC

** Turn off nux and noisy UI

No scroll, tool, menu bars
#+BEGIN_SRC emacs-lisp tangle: yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

Scratch buffer can just be empty, thanks
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq initial-scratch-message nil)
#+END_SRC

No NUX
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq inhibit-splash-screen t
			inhibit-startup-message t
			inhibit-startup-echo-area-message t)
#+END_SRC

No bell, thanks
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq ring-bell-function 'ignore)
#+END_SRC

* Navigation
** Enable ibuffer
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package ibuffer-vc
    :ensure t
    :bind ("C-x C-b" . ibuffer)
    :init
    (setq ibuffer-default-sorting-mode 'major-mode))
#+END_SRC

** Save Point Positions Between Sessions
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package saveplace
  	:config
  	(setq-default save-place t)
  	(setq save-place-file (expand-file-name ".places" "~/tmp/saves")))
#+END_SRC

** Popwin
Popwin give us special temporary behavior for certain buffers. This
lets them pop in and out in a way that I like better than the
default behavior of taking over the other-buffer

#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package popwin
  	:config
  	(progn
  		(setq popwin:special-display-config nil)
  		(push '("*Ibuffer*"
	      :dedicated t :position top    :stick t :noselect t   :height 30)
	    popwin:special-display-config)
  		(push '("*Backtrace*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("*compilation*"
	      :dedicated t :position bottom :stick t :noselect t   :height 0.5)
	    popwin:special-display-config)
  		(push '("*Compile-Log*"
	      :dedicated t :position bottom :stick t :noselect t   :height 0.33)
	    popwin:special-display-config)
  		(push '("*Help*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("*Shell Command Output*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '(" *undo-tree*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("*Warnings*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("^\\*Man .*\\*$"
	      :regexp t    :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(popwin-mode 1)))


  ;; (setq popwin:special-display-config
  ;;     (quote
  ;;      (("*Ibuffer*" :position top :noselect t :height 30)
  ;;       ("*Python Check*" :position top :noselect t :height 30)
  ;;       ("*compilation*")
  ;;       ("*Python Doc*")
  ;;       ("*xref*")
  ;;       ("*grep*")
  ;;       ("*Help*")
  ;;       ("*Completions*" :noselect t)
  ;;       ("*Occur*" :noselect t)))))
#+END_SRC

** Splitting
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq split-height-threshold 10000
	split-width-threshold 10000)
#+END_SRC

** Enable win-switch

Super nice to switch between frames and buffers
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package win-switch
	:bind (("C-x o" . win-switch-dispatch))
	:config
	(setq win-switch-provide-visual-feedback t
	  win-switch-feedback-background-color "purple"
	  win-switch-feedback-foreground-color "white")
	(win-switch-setup-keys-default))
#+END_SRC

** Expand Region
it's awsome
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package expand-region
	 :commands er/expand-region
	 :bind ("C-=" . er/expand-region))
#+END_SRC

** Searching
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq case-fold-search t)
  (setq tags-case-fold-search nil)
#+END_SRC

** Subword movement in prog-mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

** Replace 'yes/no' by just 'y/n'
#+BEGIN_SRC emacs-lisp tangle: yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Editing
** Text-mode is a better default than fundamental for me
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq-default major-mode 'text-mode)
#+END_SRC

** git-gutter-mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package git-gutter
    :diminish git-gutter-mode
    :commands (git-gutter-mode)
    :bind (:map vc-prefix-map
	("[" . git-gutter:previous-hunk)
	("]" . git-gutter:next-hunk)
	("n" . git-gutter:revert-hunk)
	("SPC" . git-gutter:mark-hunk))
    :init
    (global-git-gutter-mode)
    :config
    (setq git-gutter:handled-backends '(git)))
#+END_SRC

** Disable warnings about large files
I'm not afraid of large files, yo
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq large-file-warning-threshold nil)
#+END_SRC

** Completions
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package corfu
  	:ensure t
  	;; Optional customizations
  	:custom
  	(corfu-cycle t)                 ; Allows cycling through candidates
  	(corfu-auto t)                  ; Enable auto completion
  	(corfu-auto-prefix 2)           ; Minimum length of prefix for completion
  	(corfu-auto-delay 0)            ; No delay for completion
  	(corfu-popupinfo-delay '(0.5 . 0.2))  ; Automatically update info popup after that numver of seconds
  	(corfu-preview-current 'insert) ; insert previewed candidate
  	(corfu-preselect 'prompt)
  	(corfu-on-exact-match nil)      ; Don't auto expand tempel snippets
  	;; Optionally use TAB for cycling, default is `corfu-complete'.
  	:bind (:map corfu-map
  	("M-SPC"      . corfu-insert-separator)
  	("TAB"        . corfu-next)
  	([tab]        . corfu-next)
  	("S-TAB"      . corfu-previous)
  	([backtab]    . corfu-previous)
  	("S-<return>" . corfu-insert)
  	("RET"        . corfu-insert))

  	:init
  	(global-corfu-mode)
  	(corfu-history-mode)
  	(corfu-popupinfo-mode) ; Popup completion info
  	:config
  	(add-hook 'eshell-mode-hook
	(lambda () (setq-local corfu-quit-at-boundary t
	     corfu-quit-no-match t
	     corfu-auto nil)
  	(corfu-mode))
	nil
	t))
#+END_SRC

** Flycheck

Flycheck for use with LSPs
#+BEGIN_SRC python tangle: yes
  (use-package flycheck
	  :ensure t
	  :hook
	  (lsp-mode . flycheck-mode)
	  :bind (
	   :map flycheck-mode-map
	   ("M-n" . flycheck-next-error)
	   ("M-p" . flycheck-previous-error)))
#+END_SRC
** Multiple Cursors                                                             :today:
	 Multi-cursor editing is so cool when you can do it. Useful when
	 editing many similar lines. More interactive than macros.
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package multiple-cursors
	:bind (("M-c" . mc/edit-lines)
				 ("C->" . mc/mark-next-like-this)
				 ("C-<" . mc/mark-previous-like-this)
				 ("C-c C-<" . mc/mark-all-like-this)
				 ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

** Revert a buffer
#+BEGIN_SRC emacs-lisp tangle: yes
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC
** Backups
#+BEGIN_SRC emacs-lisp tangle: yes
  (defvar user-temporary-file-directory "~/tmp/saves/"
	(concat temporary-file-directory user-login-name "/"))

  (make-directory user-temporary-file-directory t)

  (setq
   make-backup-files t

   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
   '(("." . user-temporary-file-directory))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups

  (setq vc-make-backup-files t)

  (setq backup-directory-alist
			`((".*" . ,user-temporary-file-directory)))
  (setq auto-save-file-name-transforms
			`((".*" ,user-temporary-file-directory t)))
  (setq auto-save-list-file-prefix
			(concat user-temporary-file-directory ".auto-saves-"))
#+END_SRC

** Revert Files When They Change On Disk
#+BEGIN_SRC emacs-lisp tangle: yes
  (global-auto-revert-mode t)
#+END_SRC

** Make scripts executable on save
#+BEGIN_SRC emacs-lisp tangle: yes
  (add-hook 'after-save-hook
					'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Unfill paragraphs
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun unfill-paragraph ()
	"Takes a multi-line paragraph and makes it into a single line of text."
	(interactive)
	(let ((fill-column (point-max)))
		(fill-paragraph nil)))

  (global-set-key (kbd "M-Q") 'unfill-paragraph)
#+END_SRC
** Code Formatting
*** Columns
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq fill-column 78)
#+END_SRC

*** Default Indentation
c-basic-offset is used by most major modes I use as the basis for
how deeply to indent any code.

#+BEGIN_SRC emacs-lisp tangle: yes
  (setq c-basic-offset 1)
#+END_SRC

*** Whitespace
I don't highlight trailing whitespace, because I auto-kill it anyway
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq-default show-trailing-whitespace nil)
#+END_SRC

And here we do the killing
#+BEGIN_SRC emacs-lisp tangle: yes
(add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

*** Add newline to the end of files
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq require-final-newline t)
#+END_SRC

*** Set Unix file coding system
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (setq-default default-buffer-file-coding-system 'utf-8-unix)
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+END_SRC

** LSP
  Nothing...

* Utilities
** Edit Current Buffer As root
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun sudo ()
  	"Use TRAMP to `sudo' the current buffer"
  	(interactive)
  	(when buffer-file-name
  		(find-alternate-file
  		 (concat "/sudo:root@localhost:"
	       buffer-file-name))))
#+END_SRC
** Sort Lines In Paragraph
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun jallen-sort-para ()
  	"Sorts the paragraph in which the point is located"
  	(interactive)
  	(save-excursion
  		(let (bpoint epoint)
	(backward-paragraph)
	(setq bpoint (point))
	(forward-paragraph)
	(setq epoint (point))
	(sort-lines nil bpoint epoint)
	)
  		))
#+END_SRC
** Increment/Decrement number at point
Because why not?
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun increment-number-at-point ()
  	(interactive)
  	(skip-chars-backward "0-9")
  	(or (looking-at "[0-9]+")
	(error "No number at point"))
  	(replace-match (number-to-string (1+ (string-to-number (match-string 0))))))

  (defun decrement-number-at-point ()
  	(interactive)
  	(skip-chars-backward "0-9")
  	(or (looking-at "[0-9]+")
	(error "No number at point"))
  	(replace-match (number-to-string (- (string-to-number (match-string 0)) 1))))
#+END_SRC
** Better regex-builder
'string' does not require the crazy double escape thing from emacs regexes
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package re-builder
  	:config
  	(setq reb-re-syntax 'string))
#+END_SRC
** echo-keys
	This is useful for screen capture videos

	#+BEGIN_SRC emacs-lisp tangle: yes
		(defvar *echo-keys-last* nil "Last command processed by `echo-keys'.")

		(defun echo-keys ()
			(interactive)
			(let ((deactivate-mark deactivate-mark))
				(when (this-command-keys)
					(with-current-buffer (get-buffer-create "*echo-key*")
						(goto-char (point-max))
						;; self  self
						;; self  other \n
						;; other self  \n
						;; other other \n
						(unless (and (eq 'self-insert-command *echo-keys-last*)
												 (eq 'self-insert-command this-command))
							(insert "\n"))
						(if (eql this-command 'self-insert-command)
								(let ((desc (key-description (this-command-keys))))
									(if (= 1 (length desc))
											(insert desc)
										(insert " " desc " ")))
							(insert (key-description (this-command-keys))))
						(setf *echo-keys-last* this-command)
						(dolist (window (window-list))
							(when (eq (window-buffer window) (current-buffer))
								;; We need to use both to get the effect.
								(set-window-point window (point))
								(end-of-buffer)))))))

		(defun toggle-echo-keys ()
			(interactive)
			(if (member 'echo-keys  pre-command-hook)
					(progn
						(remove-hook 'pre-command-hook 'echo-keys)
						(dolist (window (window-list))
							(when (eq (window-buffer window) (get-buffer "*echo-key*"))
								(delete-window window))))
				(progn
					(add-hook    'pre-command-hook 'echo-keys)
					(delete-other-windows)
					(split-window nil (- (window-width) 32) t)
					(other-window 1)
					(switch-to-buffer (get-buffer-create "*echo-key*"))
					(set-window-dedicated-p (selected-window) t)
					(other-window 1))))
	#+END_SRC
** Toggle Magic
	https://endlessparentheses.com/the-toggle-map-and-wizardry.html
#+BEGIN_SRC emacs-lisp tangle: yes
	(define-prefix-command 'endless/toggle-map)
	;; The manual recommends C-c for user keys, but C-x t is
	;; always free, whereas C-c t is used by some modes.
	(define-key ctl-x-map "t" 'endless/toggle-map)
	(define-key endless/toggle-map "c" #'column-number-mode)
	(define-key endless/toggle-map "d" #'toggle-debug-on-error)
	(define-key endless/toggle-map "e" #'toggle-debug-on-error)
	(define-key endless/toggle-map "f" #'auto-fill-mode)
	(define-key endless/toggle-map "l" #'toggle-truncate-lines)
	(define-key endless/toggle-map "q" #'toggle-debug-on-quit)
	;;; Generalized version of `read-only-mode'.
	(define-key endless/toggle-map "r" #'dired-toggle-read-only)
	(autoload 'dired-toggle-read-only "dired" nil t)
	(define-key endless/toggle-map "w" #'whitespace-mode)
#+END_SRC

* Snippets
Snippets are are awesome. They are found in ~/emacs.d/snippets
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package yasnippet
  :diminish yas-minor-mode
  :config (yas-global-mode 1))
* Modes
** Treesitter Grammars / Languages
Stolen from https://www.ovistoica.com/blog/2024-7-05-modern-emacs-typescript-web-tsx-config#orgb6fd011
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package tree-sitter
    :ensure t
    :hook ((python-mode . tree-sitter-mode)
	   (tree-sitter-after-on . tree-sitter-hl-mode))
    :config
    ;; enable Tree-sitter everywhere it’s supported
    (global-tree-sitter-mode))

  (use-package tree-sitter-langs
    :ensure t
    :after tree-sitter)
 #+END_SRC

** ediff

Add a special command line switch to emacs so that we can easily use
emacs as our diff tool.

#+BEGIN_SRC bash
emacs -diff file1 file2
#+END_SRC

#+BEGIN_SRC emacs-lisp tangle: yes
  (defun command-line-diff (switch)
  	(let ((file1 (pop command-line-args-left))
	  (file2 (pop command-line-args-left)))
  		(ediff file1 file2)))

  (add-to-list 'command-switch-alist '("diff" . command-line-diff))

  (add-hook 'ediff-load-hook
	    (lambda ()
	      (message "getting my diff onnnnn")
	      (setq ediff-highlight-all-diffs nil)
	      (set-face-background
	       ediff-current-diff-face-A "#1e2424")
	      (set-face-background
	       ediff-current-diff-face-B "#1e2424")
	      (set-face-background
	       ediff-current-diff-face-C "#1e2424")
	      (make-face-italic
	       ediff-current-diff-face-A)
	      (make-face-italic
	       ediff-current-diff-face-B)
	      (make-face-italic
	       ediff-current-diff-face-C)))
#+END_SRC

** elisp
*** Turn on eldoc-mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package eldoc
	 :diminish eldoc-mode
	 :config (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+END_SRC

*** Enable slime-nav
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package elisp-slime-nav
	 :diminish elisp-slime-nav-mode
	 :config
	 (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t))))
#+END_SRC

*** Enable =rainbow-delimiters=
But only for emacs-lisp
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package rainbow-delimiters
	:config
	(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

*** package-lint for authoring packages
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package package-lint)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package markdown-mode
	:mode (("\\.text\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode)
	   ("README\\.md\\'" . gfm-mode)))
#+END_SRC

** YAML
Enable =yaml-mode=
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package yaml-mode
	:mode (("\\.lock$" . yaml-ts-mode)
	   ("\\.yml$" . yaml-ts-mode)
	   ("\\.yaml$" . yaml-ts-mode)))

#+END_SRC

** Rust
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package company
    :hook (prog-mode . company-mode)
    :config
    (setq company-minimum-prefix-length 1
	  company-idle-delay 0.2))

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((lsp-mode . lsp-enable-which-key-integration)
	   (rust-mode . lsp-deferred))
    :custom
    (lsp-log-io nil)
    (lsp-keymap-prefix "C-c l")

    ;; lsp proper
    (lsp-eldoc-render-all t)
    (lsp-idle-delay 0.8)
    (lsp-enable-snippet t)

    ;; Rust Settings
    (lsp-rust-server 'rust-analyzer)
    (lsp-rust-analyzer-server-display-inlay-hints t)
    (lsp-rust-analyzer-proc-macro-enable t)
    (lsp-rust-analyzer-cargo-watch-command "clippy"))

  (use-package lsp-ui
    :after lsp-mode
    :commands (lsp-ui-mode lsp-ui-peek-find-definitions lsp-ui-peek-find-references)
    :init
    ;; Disable the sideline completely
    (setq lsp-ui-sideline-enable nil)

    ;; Enable the hover/documentation pop-up
    (setq lsp-ui-doc-enable t
	  lsp-ui-doc-delay 0.5        ;; delay before showing doc
	  lsp-ui-doc-show-with-cursor nil
	  lsp-ui-doc-show-with-mouse t)

    ;; Enable the “peek” UI (jump-to-definition/references in a popup)
    (setq lsp-ui-peek-enable t
	  lsp-ui-peek-peek-height 20
	  lsp-ui-peek-list-width 50)

    ;; Enable the Imenu window on the side
    (setq lsp-ui-imenu-enable t
	  lsp-ui-imenu-kind-position 'left)

    ;; Optionally enable a flycheck-style fringe indicator instead of sideline
	(setq lsp-ui-flycheck-enable t)

    :hook
    (lsp-mode . lsp-ui-mode)

    :config
    ;; Example keybindings to trigger “peek” commands:
    (define-key lsp-mode-map (kbd "C-c l d") #'lsp-ui-peek-find-definitions)
    (define-key lsp-mode-map (kbd "C-c l r") #'lsp-ui-peek-find-references)

    ;; Optional: adjust how the doc frame looks
    (setq lsp-ui-doc-use-webkit t             ;; if you want richer rendering
	  lsp-ui-doc-position 'at-point)      ;; or ’top or ’bottom or ’at-point
    )

  (use-package rust-mode
    :ensure t
    :bind (
	   ("C-c C-s" . rust-compile)
	   ("C-c C-t" . rust-test))
    :config
    (setq rust-format-on-save t)
	:hook (
				 rust-mode . (lambda ()
											 ;; Use spaces, not tabs
											 (setq indent-tabs-mode nil)
											 (setq tab-width 4))))

  (use-package cargo
    :ensure t
    :hook
    (rust-mode . cargo-minor-mode))

  (use-package toml-mode
    :ensure t
    :mode "\\.toml\\'")
 #+END_SRC

** Python
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package python
    :ensure nil
      :mode ("\\.py\\'" . python-mode)
      :hook ((python-mode . (lambda ()
	 (setq indent-tabs-mode t)
	 (setq python-indent-offset 2)))
       (python-mode . tree-sitter-mode)
       (python-mode . tree-sitter-hl-mode))
      :config
      (setq python-shell-interpreter "python3"
      python-shell-interpreter-args "-i"))
#+END_SRC
