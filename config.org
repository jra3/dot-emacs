#+TITLE: Emacs Configuration
#+AUTHOR: John Allen
#+STARTUP: overview

* mac magic
#+BEGIN_SRC emacs-lisp tangle: yes
  ;; Keybonds
  (global-set-key [(hyper a)] 'mark-whole-buffer)
  (global-set-key [(hyper v)] 'yank)
  (global-set-key [(hyper c)] 'kill-ring-save)
  (global-set-key [(hyper s)] 'save-buffer)
  (global-set-key [(hyper l)] 'goto-line)
  (global-set-key [(hyper w)]
		  (lambda () (interactive) (delete-window)))
  (global-set-key [(hyper z)] 'undo)

  (setq mac-option-modifier 'meta)
  (setq mac-command-modifier 'hyper)

#+END_SRC

Mac tries to hide your $PATH from you when using a graphical mode

#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package exec-path-from-shell
  	:if (memq window-system '(mac ns))
  	:config
  	(exec-path-from-shell-initialize))
#+END_SRC

* Configure Helm
Make everything fuzzy and also rebind functions.
#+BEGIN_SRC python tangle: no
  (use-package flx)
  (use-package helm-flx)
  (use-package helm-descbinds)
  (use-package helm
   :demand
    :diminish helm-mode
    :bind (
     ("M-x" . helm-M-x)
     ("M-y" . helm-show-kill-ring)
     ("C-x b" . helm-mini)
     ("C-x C-f" . helm-find-files)
     ("C-x r l" . helm-bookmarks)
     ("C-c C-i" . helm-semantic-or-imenu)
     :map helm-find-files-map ;; I like these from Ido
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-<backspace>" . helm-find-files-up-one-level))
    :config
    (helm-mode 1)
    (helm-descbinds-mode)
    (helm-flx-mode +1)
    (setq helm-M-x-fuzzy-match t
    helm-buffers-fuzzy-matching t
    helm-recentf-fuzzy-match t
    helm-locate-fuzzy-match t
    helm-lisp-fuzzy-completion t
    helm-bookmark-show-location t))

  (use-package helm-xref
    :config
    (setq xref-show-xrefs-function 'helm-xref-show-xrefs))

#+END_SRC
* Configure Completions
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package vertico
    :ensure t
    :diminish vertico-mode
    :init
    (savehist-mode 1)
    :config
    (vertico-mode 1)
    (setq vertico-cycle t))

  (use-package marginalia
    :ensure t
    :after vertico
    :diminish marginalia-mode
    :config
    (marginalia-mode 1))

  (use-package consult
  	:ensure t
  	:bind (
  		("C-x b" . consult-buffer)
  		("C-s" . consult-line)
  		("M-o" . consult-find)
  		("M-l" . consult-goto-line)
  		("M-s l" . consult-locate)
  		("M-s g" . consult-git-grep)
  		("M-s s" . consult-ripgrep)
  		("C-x r l" . consult-bookmark)
  		("C-c C-i" . consult-imenu))
  :init
  (setq
   consult-locate-args "mdfind -name %s 2>/dev/null"
   xref-show-xrefs-function #'consult-xref
   xref-show-definitions-function #'consult-xref))

  (use-package orderless
      :ensure t
      :init
      (setq completion-styles '(orderless basic)
      completion-category-defaults nil
      completion-category-overrides '((file (styles partial-completion)))))

  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)         ;; pick some action on the current candidate
     ("C-;" . embark-dwim))       ;; "do what I mean" (contextual) action
    :init
    ;; Show Embark actions in the minibuffer-side window
    (setq embark-indicators '(embark-minimal-indicator embark-which-key-indicator))
    :config
    ;; Optionally, use which-key to display available actions
    (setq embark-which-key-prefix ","))

  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :config
    ;; If you want Embark actions to integrate with Consult previews:
    (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode))

#+END_SRC
* Customization File
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq custom-file (concat config-load-path "custom.el"))
  (load custom-file)
#+END_SRC

* Appearance
** Fonts
Install fonts from my .emacs.d into system locations
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun jallen-install-font ()
  	"copy my font files into the system-specific location"
  	(let ((fonts-source "~/.emacs.d/Input_Fonts/"))
  		(if (string-equal system-type "darwin")
	  (copy-directory fonts-source "~/Library/Fonts/") ; Mac
	(copy-directory fonts-source "~/.fonts/") ; Linux
	)
  		))

  (add-hook 'before-make-frame-hook
	    (lambda ()
	      (if (-any '(lambda (fonts) (string-prefix-p "-*-Input " (elt fonts 6))) (x-family-fonts))
		  (jallen-install-font))))

#+END_SRC

Define some shortcuts for sizes that I use sometimes
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun jallen-font () (interactive)
	 (set-frame-font "Input Mono Narrow-16"))
  (defun jallen-font-no-contacts () (interactive)
	 (set-frame-font "Input Mono Narrow-22"))
  (defun jallen-blind () (interactive)
	 (set-frame-font "Input Mono Narrow-30"))
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package tangotango-theme
		:ensure t
		:config
		(load-theme 'tangotango t))
#+END_SRC

isearch faces customizations
#+BEGIN_SRC emacs-lisp tangle: yes
	(set-face-foreground 'lazy-highlight "black")
	(set-face-background 'lazy-highlight "yellow")
	(set-face-foreground 'isearch "white")
	(set-face-background 'isearch "blue")
#+END_SRC

** Frame Settings

Titles
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq frame-title-format (concat  "%b - emacs@" system-name))
#+END_SRC

Frame Configuration
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq default-frame-alist
	(quote
	 ((left-fringe . 1)
	  (right-fringe . 1)
	  (menu-bar-lines . 0)
	  (tool-bar-lines . 0)
	  (font . "Input Mono Narrow-16")
	  )))
#+END_SRC

Uniqify Buffer Names
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package uniquify
    :ensure nil  ;; built-in
    :init
    (setq uniquify-buffer-name-style 'reverse
	  uniquify-separator "|"
	  uniquify-after-kill-buffer-p t
	  uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

Show lines and columns
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq line-number-mode t
	column-number-mode t)
#+END_SRC

Show number and ordinality of matching
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package anzu
	:config (global-anzu-mode +1)
	(setq anzu-mode-lighter ""))
#+END_SRC

Highlight the selected region
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq transient-mark-mode t)
#+END_SRC

https://www.emacswiki.org/emacs/SmoothScrolling
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq scroll-step 1
			scroll-conservatively 10000
			mouse-wheel-scroll-amount '(1 ((shift) . 1))
			mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
			mouse-wheel-follow-mouse t) ;; scroll window under mouse
#+END_SRC

** Turn off nux and noisy UI

No scroll, tool, menu bars
#+BEGIN_SRC emacs-lisp tangle: yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

Scratch buffer can just be empty, thanks
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq initial-scratch-message nil)
#+END_SRC

No NUX
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq inhibit-splash-screen t
			inhibit-startup-message t
			inhibit-startup-echo-area-message t)
#+END_SRC

No bell, thanks
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq ring-bell-function 'ignore)
#+END_SRC

* Navigation
** Enable ibuffer
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package ibuffer-vc
    :ensure t
    :bind ("C-x C-b" . ibuffer)
    :init
    (setq ibuffer-default-sorting-mode 'major-mode))
#+END_SRC

** Save Point Positions Between Sessions
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package saveplace
  	:config
  	(setq-default save-place t)
  	(setq save-place-file (expand-file-name ".places" "~/tmp/saves")))
#+END_SRC

** Popwin
Popwin give us special temporary behavior for certain buffers. This
lets them pop in and out in a way that I like better than the
default behavior of taking over the other-buffer

#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package popwin
  	:config
  	(progn
  		(setq popwin:special-display-config nil)
  		(push '("*Ibuffer*"
	      :dedicated t :position top    :stick t :noselect t   :height 30)
	    popwin:special-display-config)
  		(push '("*Backtrace*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("*compilation*"
	      :dedicated t :position bottom :stick t :noselect t   :height 0.5)
	    popwin:special-display-config)
  		(push '("*Compile-Log*"
	      :dedicated t :position bottom :stick t :noselect t   :height 0.33)
	    popwin:special-display-config)
  		(push '("*Help*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("*Shell Command Output*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '(" *undo-tree*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("*Warnings*"
	      :dedicated t :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(push '("^\\*Man .*\\*$"
	      :regexp t    :position bottom :stick t :noselect nil :height 0.33)
	    popwin:special-display-config)
  		(popwin-mode 1)))


  ;; (setq popwin:special-display-config
  ;;     (quote
  ;;      (("*Ibuffer*" :position top :noselect t :height 30)
  ;;       ("*Python Check*" :position top :noselect t :height 30)
  ;;       ("*compilation*")
  ;;       ("*Python Doc*")
  ;;       ("*xref*")
  ;;       ("*grep*")
  ;;       ("*Help*")
  ;;       ("*Completions*" :noselect t)
  ;;       ("*Occur*" :noselect t)))))
#+END_SRC

** Splitting
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq split-height-threshold 10000
	split-width-threshold 10000)
#+END_SRC

** Enable win-switch

Super nice to switch between frames and buffers
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package win-switch
	:bind (("C-x o" . win-switch-dispatch))
	:config
	(setq win-switch-provide-visual-feedback t
	  win-switch-feedback-background-color "purple"
	  win-switch-feedback-foreground-color "white")
	(win-switch-setup-keys-default))
#+END_SRC

** Expand Region
it's awsome
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package expand-region
	 :commands er/expand-region
	 :bind ("C-=" . er/expand-region))
#+END_SRC

** Searching
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq case-fold-search t)
  (setq tags-case-fold-search nil)
#+END_SRC

** Subword movement in prog-mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

** Replace 'yes/no' by just 'y/n'
#+BEGIN_SRC emacs-lisp tangle: yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Editing
** Text-mode is a better default than fundamental for me
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq-default major-mode 'text-mode)
#+END_SRC

** git-gutter-mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package git-gutter
    :diminish git-gutter-mode
    :commands (git-gutter-mode)
    :bind (:map vc-prefix-map
	("[" . git-gutter:previous-hunk)
	("]" . git-gutter:next-hunk)
	("n" . git-gutter:revert-hunk)
	("SPC" . git-gutter:mark-hunk))
    :init
    (global-git-gutter-mode)
    :config
    (setq git-gutter:handled-backends '(git)))
#+END_SRC

** Disable warnings about large files
I'm not afraid of large files, yo
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq large-file-warning-threshold nil)
#+END_SRC

** Snippets
Snippets are are awesome. They are found in ~/emacs.d/snippets
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package yasnippet
  :diminish yas-minor-mode
  :config (yas-global-mode 1))

** Completions
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package corfu
  	:ensure t
  	;; Optional customizations
  	:custom
  	(corfu-cycle t)                 ; Allows cycling through candidates
  	(corfu-auto t)                  ; Enable auto completion
  	(corfu-auto-prefix 2)           ; Minimum length of prefix for completion
  	(corfu-auto-delay 0)            ; No delay for completion
  	(corfu-popupinfo-delay '(0.5 . 0.2))  ; Automatically update info popup after that numver of seconds
  	(corfu-preview-current 'insert) ; insert previewed candidate
  	(corfu-preselect 'prompt)
  	(corfu-on-exact-match nil)      ; Don't auto expand tempel snippets
  	;; Optionally use TAB for cycling, default is `corfu-complete'.
  	:bind (:map corfu-map
  	("M-SPC"      . corfu-insert-separator)
  	("TAB"        . corfu-next)
  	([tab]        . corfu-next)
  	("S-TAB"      . corfu-previous)
  	([backtab]    . corfu-previous)
  	("S-<return>" . corfu-insert)
  	("RET"        . corfu-insert))

  	:init
  	(global-corfu-mode)
  	(corfu-history-mode)
  	(corfu-popupinfo-mode) ; Popup completion info
  	:config
  	(add-hook 'eshell-mode-hook
	(lambda () (setq-local corfu-quit-at-boundary t
	     corfu-quit-no-match t
	     corfu-auto nil)
  	(corfu-mode))
	nil
	t))
#+END_SRC

** Flycheck

Flycheck for use with LSPs
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package flycheck
    :ensure t
    :hook
    (lsp-mode . flycheck-mode)
    :bind (
	   :map flycheck-mode-map
	   ("M-n" . flycheck-next-error)
	   ("M-p" . flycheck-previous-error)))
#+END_SRC
** Multiple Cursors                                                             :today:
	 Multi-cursor editing is so cool when you can do it. Useful when
	 editing many similar lines. More interactive than macros.
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package multiple-cursors
	:bind (("M-c" . mc/edit-lines)
				 ("C->" . mc/mark-next-like-this)
				 ("C-<" . mc/mark-previous-like-this)
				 ("C-c C-<" . mc/mark-all-like-this)
				 ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

** Revert a buffer
#+BEGIN_SRC emacs-lisp tangle: yes
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC
** Backups
#+BEGIN_SRC emacs-lisp tangle: yes
  (defvar user-temporary-file-directory "~/tmp/saves/"
	(concat temporary-file-directory user-login-name "/"))

  (make-directory user-temporary-file-directory t)

  (setq
   make-backup-files t

   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
   '(("." . user-temporary-file-directory))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups

  (setq vc-make-backup-files t)

  (setq backup-directory-alist
			`((".*" . ,user-temporary-file-directory)))
  (setq auto-save-file-name-transforms
			`((".*" ,user-temporary-file-directory t)))
  (setq auto-save-list-file-prefix
			(concat user-temporary-file-directory ".auto-saves-"))
#+END_SRC

** Revert Files When They Change On Disk
#+BEGIN_SRC emacs-lisp tangle: yes
  (global-auto-revert-mode t)
#+END_SRC

** Make scripts executable on save
#+BEGIN_SRC emacs-lisp tangle: yes
  (add-hook 'after-save-hook
					'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Unfill paragraphs
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun unfill-paragraph ()
	"Takes a multi-line paragraph and makes it into a single line of text."
	(interactive)
	(let ((fill-column (point-max)))
		(fill-paragraph nil)))

  (global-set-key (kbd "M-Q") 'unfill-paragraph)
#+END_SRC
** Code Formatting
*** Columns
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq fill-column 78)
#+END_SRC

*** Default Indentation
c-basic-offset is used by most major modes I use as the basis for
how deeply to indent any code.

#+BEGIN_SRC emacs-lisp tangle: yes
  (setq c-basic-offset 1)
#+END_SRC

*** Whitespace
I don't highlight trailing whitespace, because I auto-kill it anyway
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq-default show-trailing-whitespace nil)
#+END_SRC

And here we do the killing
#+BEGIN_SRC emacs-lisp tangle: yes
(add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

*** Add newline to the end of files
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq require-final-newline t)
#+END_SRC

*** Set Unix file coding system
#+BEGIN_SRC emacs-lisp tangle: yes
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (setq-default default-buffer-file-coding-system 'utf-8-unix)
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+END_SRC

** LSP

#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package company
    :hook (prog-mode . company-mode)
    :config
    (setq company-minimum-prefix-length 1
    company-idle-delay 0.2))

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((lsp-mode           . lsp-enable-which-key-integration)
     (lsp-mode           . lsp-diagnostics-mode)
     (rust-ts-mode       . lsp-deferred)
     (c-ts-mode          . lsp-deferred)
     (c++-ts-mode        . lsp-deferred)
     (typescript-ts-mode . lsp-deferred))

    :custom
    (lsp-log-io nil)                      ; IMPORTANT! Use only for debugging! Drastically affects performance

  	(lsp-keymap-prefix "C-c l")           ; Prefix for LSP actions
  	;;(lsp-completion-provider :none)     ; Using Corfu as the provider
  	(lsp-diagnostics-provider :flycheck)
  	(lsp-session-file (locate-user-emacs-file ".lsp-session"))

  	(lsp-keep-workspace-alive nil)        ; Close LSP server if all project buffers are closed
  	(lsp-idle-delay 0.5)                  ; Debounce timer for `after-change-function'
  	;; core
  	(lsp-enable-xref t)                   ; Use xref to find references
  	(lsp-auto-configure t)                ; Used to decide between current active servers
  	(lsp-eldoc-enable-hover t)            ; Display signature information in the echo area
  	(lsp-enable-dap-auto-configure t)     ; Debug support
  	(lsp-enable-file-watchers nil)
  	(lsp-enable-folding nil)              ; I disable folding since I use origami
  	(lsp-enable-imenu t)
  	(lsp-enable-indentation nil)          ; I use prettier
  	(lsp-enable-links nil)                ; No need since we have `browse-url'
  	(lsp-enable-on-type-formatting nil)   ; Prettier handles this
  	(lsp-enable-suggest-server-download t) ; Useful prompt to download LSP providers
  	(lsp-enable-symbol-highlighting t)     ; Shows usages of symbol at point in the current buffer
  	(lsp-enable-text-document-color nil)   ; This is Treesitter's job

  	(lsp-ui-sideline-show-hover nil)      ; Sideline used only for diagnostics
  	(lsp-ui-sideline-diagnostic-max-lines 20) ; 20 lines since typescript errors can be quite big
  	;; completion
  	(lsp-completion-enable t)
  	(lsp-completion-enable-additional-text-edit t) ; Ex: auto-insert an import for a completion candidate
  	(lsp-enable-snippet t)
  	(lsp-completion-show-kind t)                   ; Optional
  	;; headerline
  	(lsp-headerline-breadcrumb-enable t)  ; Optional, I like the breadcrumbs
  	(lsp-headerline-breadcrumb-enable-diagnostics nil) ; Don't make them red, too noisy
  	(lsp-headerline-breadcrumb-enable-symbol-numbers nil)
  	(lsp-headerline-breadcrumb-icons-enable nil)
  	;; modeline
  	(lsp-modeline-code-actions-enable t) ; Modeline should be relatively clean
  	(lsp-modeline-diagnostics-enable nil)  ; Already supported through `flycheck'
  	(lsp-modeline-workspace-status-enable nil) ; Modeline displays "LSP" when lsp-mode is enabled
  	(lsp-signature-doc-lines 1)           ; Don't raise the echo area. It's distracting
  	(lsp-ui-doc-use-childframe t)         ; Show docs for symbol at point
  	(lsp-eldoc-render-all nil)            ; This would be very useful if it would respect `lsp-signature-doc-lines', currently it's distracting
  	;; lens
  	(lsp-lens-enable nil)                 ; Optional, I don't need it
  	;; semantic
  	(lsp-semantic-tokens-enable nil)      ; Related to highlighting, and we defer to treesitter

  	;; C/C++
  	(lsp-clients-clangd-args  '("--header-insertion=never"))

  	;; rust
  	(lsp-rust-server 'rust-analyzer)
  	(lsp-rust-analyzer-server-display-inlay-hints t)
  	(lsp-rust-analyzer-proc-macro-enable t)
  	(lsp-rust-analyzer-cargo-watch-command "clippy"))


  (use-package lsp-ui
    :after lsp-mode
    :commands (lsp-ui-mode lsp-ui-peek-find-definitions lsp-ui-peek-find-references)
    :init
    (setq lsp-ui-sideline-enable nil)

    (setq lsp-ui-doc-enable t
    lsp-ui-doc-delay 0.5        ;; delay before showing doc
    lsp-ui-doc-show-with-cursor nil
    lsp-ui-doc-show-with-mouse t)

    (setq lsp-ui-peek-enable t
    lsp-ui-peek-peek-height 20
    lsp-ui-peek-list-width 50)

    (setq lsp-ui-imenu-enable t
    lsp-ui-imenu-kind-position 'left)

    (setq lsp-ui-flycheck-enable t)

    :hook
    (lsp-mode . lsp-ui-mode)

    :config
    (define-key lsp-mode-map (kbd "C-c l d") #'lsp-ui-peek-find-definitions)
    (define-key lsp-mode-map (kbd "C-c l r") #'lsp-ui-peek-find-references)
    (setq lsp-ui-doc-use-webkit t
    lsp-ui-doc-position 'at-point))
#+END_SRC

* Utilities
** Edit Current Buffer As root
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun sudo ()
  	"Use TRAMP to `sudo' the current buffer"
  	(interactive)
  	(when buffer-file-name
  		(find-alternate-file
  		 (concat "/sudo:root@localhost:"
	       buffer-file-name))))
#+END_SRC
** Sort Lines In Paragraph
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun jallen-sort-para ()
  	"Sorts the paragraph in which the point is located"
  	(interactive)
  	(save-excursion
  		(let (bpoint epoint)
	(backward-paragraph)
	(setq bpoint (point))
	(forward-paragraph)
	(setq epoint (point))
	(sort-lines nil bpoint epoint)
	)
  		))
#+END_SRC
** Increment/Decrement number at point
Because why not?
#+BEGIN_SRC emacs-lisp tangle: yes
  (defun increment-number-at-point ()
  	(interactive)
  	(skip-chars-backward "0-9")
  	(or (looking-at "[0-9]+")
	(error "No number at point"))
  	(replace-match (number-to-string (1+ (string-to-number (match-string 0))))))

  (defun decrement-number-at-point ()
  	(interactive)
  	(skip-chars-backward "0-9")
  	(or (looking-at "[0-9]+")
	(error "No number at point"))
  	(replace-match (number-to-string (- (string-to-number (match-string 0)) 1))))
#+END_SRC
** Better regex-builder
'string' does not require the crazy double escape thing from emacs regexes
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package re-builder
  	:config
  	(setq reb-re-syntax 'string))
#+END_SRC
** echo-keys
	This is useful for screen capture videos

	#+BEGIN_SRC emacs-lisp tangle: yes
		(defvar *echo-keys-last* nil "Last command processed by `echo-keys'.")

		(defun echo-keys ()
			(interactive)
			(let ((deactivate-mark deactivate-mark))
				(when (this-command-keys)
					(with-current-buffer (get-buffer-create "*echo-key*")
						(goto-char (point-max))
						;; self  self
						;; self  other \n
						;; other self  \n
						;; other other \n
						(unless (and (eq 'self-insert-command *echo-keys-last*)
												 (eq 'self-insert-command this-command))
							(insert "\n"))
						(if (eql this-command 'self-insert-command)
								(let ((desc (key-description (this-command-keys))))
									(if (= 1 (length desc))
											(insert desc)
										(insert " " desc " ")))
							(insert (key-description (this-command-keys))))
						(setf *echo-keys-last* this-command)
						(dolist (window (window-list))
							(when (eq (window-buffer window) (current-buffer))
								;; We need to use both to get the effect.
								(set-window-point window (point))
								(end-of-buffer)))))))

		(defun toggle-echo-keys ()
			(interactive)
			(if (member 'echo-keys  pre-command-hook)
					(progn
						(remove-hook 'pre-command-hook 'echo-keys)
						(dolist (window (window-list))
							(when (eq (window-buffer window) (get-buffer "*echo-key*"))
								(delete-window window))))
				(progn
					(add-hook    'pre-command-hook 'echo-keys)
					(delete-other-windows)
					(split-window nil (- (window-width) 32) t)
					(other-window 1)
					(switch-to-buffer (get-buffer-create "*echo-key*"))
					(set-window-dedicated-p (selected-window) t)
					(other-window 1))))
	#+END_SRC
** Toggle Magic
	https://endlessparentheses.com/the-toggle-map-and-wizardry.html
#+BEGIN_SRC emacs-lisp tangle: yes
	(define-prefix-command 'endless/toggle-map)
	;; The manual recommends C-c for user keys, but C-x t is
	;; always free, whereas C-c t is used by some modes.
	(define-key ctl-x-map "t" 'endless/toggle-map)
	(define-key endless/toggle-map "c" #'column-number-mode)
	(define-key endless/toggle-map "d" #'toggle-debug-on-error)
	(define-key endless/toggle-map "e" #'toggle-debug-on-error)
	(define-key endless/toggle-map "f" #'auto-fill-mode)
	(define-key endless/toggle-map "l" #'toggle-truncate-lines)
	(define-key endless/toggle-map "q" #'toggle-debug-on-quit)
	;;; Generalized version of `read-only-mode'.
	(define-key endless/toggle-map "r" #'dired-toggle-read-only)
	(autoload 'dired-toggle-read-only "dired" nil t)
	(define-key endless/toggle-map "w" #'whitespace-mode)
#+END_SRC

** Project Management
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :config
    (projectile-mode +1)
    (setq projectile-project-search-path '("~/am/")
	  projectile-completion-system 'consult)
    :bind (:map projectile-mode-map
		("C-c p" . projectile-command-map)))

  (defun compile-go-project ()
    "Compile current Go project using make build"
    (interactive)
    (compile "make build"))

  (defun test-go-project ()
    "Test current Go project using make test"
    (interactive)
    (compile "make test"))

  (defun lint-go-project ()
    "Lint current Go project using make lint"
    (interactive)
    (compile "make lint"))

  (defun format-go-project ()
    "Format current Go project using make fmt"
    (interactive)
    (compile "make fmt"))

  (defun compile-ts-project ()
    "Compile current TypeScript project using turbo build"
    (interactive)
    (compile "turbo build"))

  (defun test-ts-project ()
    "Test current TypeScript project using turbo test"
    (interactive)
    (compile "turbo test"))

  (defun dev-ts-project ()
    "Start dev server for TypeScript project using turbo dev"
    (interactive)
    (compile "turbo dev"))

  (global-set-key (kbd "C-c m b") 'compile-go-project)
  (global-set-key (kbd "C-c m t") 'test-go-project)
  (global-set-key (kbd "C-c m l") 'lint-go-project)
  (global-set-key (kbd "C-c m f") 'format-go-project)
  (global-set-key (kbd "C-c m B") 'compile-ts-project)
  (global-set-key (kbd "C-c m T") 'test-ts-project)
  (global-set-key (kbd "C-c m d") 'dev-ts-project)
#+END_SRC

* Navigation
** Configure Windmove

	 #+BEGIN_SRC emacs-lisp tangle: yes
		 (windmove-default-keybindings 'hyper)
	 #+END_SRC

** Manipulate Window Sizes
	 C-x <arrow>
#+BEGIN_SRC emacs-lisp tangle: yes
(global-set-key
 (kbd "C-x <right>")
 '(lambda () (interactive) (enlarge-window-horizontally 4)))
(global-set-key
 (kbd "C-x <left>")
 '(lambda () (interactive) (shrink-window-horizontally 4)))
(global-set-key
 (kbd "C-x <up>")
 '(lambda () (interactive) (enlarge-window 4)))
(global-set-key
 (kbd "C-x <down>")
 '(lambda () (interactive) (shrink-window 4)))
#+END_SRC
** Popwin
	Popwin give us special temporary behavior for certain buffers. This
	lets them pop in and out in a way that I like better than the
	default behavior of taking over the other-buffer

#+BEGIN_SRC emacs-lisp tangle: yes
	(use-package popwin
		:config
		(progn
			(setq popwin:special-display-config nil)
			(push '("*Ibuffer*"
							:dedicated t :position top    :stick t :noselect t   :height 30)
						popwin:special-display-config)
			(push '("*Backtrace*"
							:dedicated t :position bottom :stick t :noselect nil :height 0.33)
						popwin:special-display-config)
			(push '("*compilation*"
							:dedicated t :position bottom :stick t :noselect t   :height 0.5)
						popwin:special-display-config)
			(push '("*Compile-Log*"
							:dedicated t :position bottom :stick t :noselect t   :height 0.33)
						popwin:special-display-config)
			(push '("*Help*"
							:dedicated t :position bottom :stick t :noselect nil :height 0.33)
						popwin:special-display-config)
			(push '("*Shell Command Output*"
							:dedicated t :position bottom :stick t :noselect nil :height 0.33)
						popwin:special-display-config)
			(push '(" *undo-tree*"
							:dedicated t :position bottom :stick t :noselect nil :height 0.33)
						popwin:special-display-config)
			(push '("*Warnings*"
							:dedicated t :position bottom :stick t :noselect nil :height 0.33)
						popwin:special-display-config)
			(push '("^\\*Man .*\\*$"
							:regexp t    :position bottom :stick t :noselect nil :height 0.33)
						popwin:special-display-config)
			(popwin-mode 1)))


	;; (setq popwin:special-display-config
	;;     (quote
	;;      (("*Ibuffer*" :position top :noselect t :height 30)
	;;       ("*Python Check*" :position top :noselect t :height 30)
	;;       ("*compilation*")
	;;       ("*Python Doc*")
	;;       ("*xref*")
	;;       ("*grep*")
	;;       ("*Help*")
	;;       ("*Completions*" :noselect t)
	;;       ("*Occur*" :noselect t)))))
#+END_SRC


** Enable win-switch
Super nice to switch between frames and buffers
#+BEGIN_SRC emacs-lisp tangle: yes
	(use-package win-switch
		:bind (("C-x o" . win-switch-dispatch))
		:config
		(setq win-switch-provide-visual-feedback t)
		(setq win-switch-feedback-background-color "purple")
		(setq win-switch-feedback-foreground-color "white")
		(win-switch-setup-keys-default))
#+END_SRC
** Enable ibuffer
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package ibuffer-vc)
(define-key global-map (kbd "C-x C-b") 'ibuffer)
(setq ibuffer-default-sorting-mode 'major-mode)
;; (define-key
;;   ibuffer-mode-map
;;   (kbd "RET")
;;   'ibuffer-visit-buffer-other-window)

#+END_SRC
** Enable =anzu=

Show number and ordinality of matching

#+BEGIN_SRC emacs-lisp tangle: yes
(use-package anzu
	:config (global-anzu-mode +1)
	(setq anzu-mode-lighter ""))
#+END_SRC

** Save Point Positions Between Sessions
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package saveplace
	:config
	(setq-default save-place t)
	(setq save-place-file (expand-file-name ".places" "~/tmp/saves")))
#+END_SRC
** narrow/widen

#+BEGIN_SRC emacs-lisp tangle: yes
	(defun narrow-or-widen-dwim (p)
		"Widen if buffer is narrowed, narrow-dwim otherwise.
		Dwim means: region, org-src-block, org-subtree, or
		defun, whichever applies first. Narrowing to
		org-src-block actually calls `org-edit-src-code'.

		With prefix P, don't widen, just narrow even if buffer
		is already narrowed."
		(interactive "P")
		(declare (interactive-only))
		(cond ((and (buffer-narrowed-p) (not p)) (widen))
					((region-active-p)
					 (narrow-to-region (region-beginning)
														 (region-end)))
					((derived-mode-p 'org-mode)
					 ;; `org-edit-src-code' is not a real narrowing
					 ;; command. Remove this first conditional if
					 ;; you don't want it.
					 (cond ((ignore-errors (org-edit-src-code) t)
									(delete-other-windows))
								 ((ignore-errors (org-narrow-to-block) t))
								 (t (org-narrow-to-subtree))))
					((derived-mode-p 'latex-mode)
					 (LaTeX-narrow-to-environment))
					(t (narrow-to-defun))))

	(define-key endless/toggle-map "n"
		#'narrow-or-widen-dwim)
	;; This line actually replaces Emacs' entire narrowing
	;; keymap, that's how much I like this command. Only
	;; copy it if that's what you want.
	(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
	(add-hook 'LaTeX-mode-hook
						(lambda ()
							(define-key LaTeX-mode-map "\C-xn"
								nil)))

	(defun jallen-org-src-save-or-close () (interactive)
				 (indent-region (point-min) (point-max))
				 (if (buffer-modified-p)
						 (save-buffer)
					 (org-edit-src-exit)))

	(eval-after-load 'org-src
		'(define-key org-src-mode-map
			 "\C-x\C-s" #'jallen-org-src-save-or-close))
#+END_SRC
** expand-region
	 it's awsome
	 #+BEGIN_SRC emacs-lisp tangle: yes
		 (use-package expand-region
			 :commands er/expand-region
			 :bind ("C-=" . er/expand-region))
	 #+END_SRC
* Appearance
** Frame Titles
#+BEGIN_SRC emacs-lisp tangle: yes
(setq frame-title-format (concat  "%b - emacs@" system-name))
#+END_SRC
** Fonts
 Install fonts from my .emacs.d into system locations
#+BEGIN_SRC emacs-lisp tangle: yes

	(defun jallen-install-font ()
		"copy my font files into the system-specific location"
		(let ((fonts-source "~/.emacs.d/Input_Fonts/"))
			(if (string-equal system-type "darwin")
					(copy-directory fonts-source "~/Library/Fonts/") ; Mac
				(copy-directory fonts-source "~/.fonts/") ; Linux
				)
			))

	(add-hook 'before-make-frame-hook
						(lambda ()
							(if (-any '(lambda (fonts) (string-prefix-p "-*-Input " (elt fonts 6))) (x-family-fonts))
									(jallen-install-font))))

#+END_SRC

Define some shortcuts for sizes that I use sometimes
#+BEGIN_SRC emacs-lisp tangle: yes
	(defun jallen-font () (interactive)
				 (set-frame-font "Input Mono Narrow-16"))
	(defun jallen-font-no-contacts () (interactive)
				 (set-frame-font "Input Mono Narrow-22"))
	(defun jallen-blind () (interactive)
				 (set-frame-font "Input Mono Narrow-30"))
#+END_SRC


** Frame Configuration
#+BEGIN_SRC emacs-lisp tangle: yes
(setq default-frame-alist
			(quote
			 ((left-fringe . 1)
				(right-fringe . 1)
				(menu-bar-lines . 0)
				(tool-bar-lines . 0)
				(font . "Input Mono Narrow-16")
				)))
#+END_SRC
** Theme
	 I love tangotango
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package tangotango-theme
	:config (load-theme 'tangotango t))
#+END_SRC
** Uniqify Buffer Names
	 TODO make this lazy load maybe?
#+BEGIN_SRC emacs-lisp tangle: yes
(require 'uniquify)
(setq uniquify-buffer-name-style 'reverse
			uniquify-separator "|"
			uniquify-after-kill-buffer-p t
			uniquify-ignore-buffers-re "^\\*")
#+END_SRC
** isearch faces
#+BEGIN_SRC emacs-lisp tangle: yes
	(set-face-foreground 'lazy-highlight "black")
	(set-face-background 'lazy-highlight "yellow")
	(set-face-foreground 'isearch "white")
	(set-face-background 'isearch "blue")
#+END_SRC
** Turn off nux and noisy UI
	 No scroll, tool, menu bars
#+BEGIN_SRC emacs-lisp tangle: yes
	(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
	(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
	(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

	 Scratch buffer can just be empty, thanks
#+BEGIN_SRC emacs-lisp tangle: yes
	(setq initial-scratch-message nil)
#+END_SRC

	 No NUX
#+BEGIN_SRC emacs-lisp tangle: yes
	(setq inhibit-splash-screen t
				inhibit-startup-message t
				inhibit-startup-echo-area-message t)
#+END_SRC

** Show lines and columns
#+BEGIN_SRC emacs-lisp tangle: yes
(setq line-number-mode t
			column-number-mode t)
#+END_SRC
** Highlight the selected region
#+BEGIN_SRC emacs-lisp tangle: yes
(setq transient-mark-mode t)
#+END_SRC
* Terminal Configuration
** Terminals in emacs should use ansi colors
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package ansi-color)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
(setq comint-prompt-read-only t)
#+END_SRC

** Deal with running emacs in terminal
	 Here is some scar tissue of me trying to make all keys work in the
terminal as they do in X11. This isn't possible as far as I can tell,
and I'm no longer sure if this does anything for me.

we are expecting an xterm compatible terminal here. tmux requires you
to set xterm-mode as a terminal option for this

#+BEGIN_SRC emacs-lisp tangle: yes
(defadvice terminal-init-xterm (after map-S-up-escape-sequence activate)
	(define-key input-decode-map "\e[1;9A" [M-up])
	(define-key input-decode-map "\e[1;9B" [M-down])
	(define-key input-decode-map "\e[1;9C" [M-right])
	(define-key input-decode-map "\e[1;9D" [M-left])

	(define-key input-decode-map "\e[1;10A" [M-S-up])
	(define-key input-decode-map "\e[1;10B" [M-S-down])
	(define-key input-decode-map "\e[1;10C" [M-S-right])
	(define-key input-decode-map "\e[1;10D" [M-S-left])

	;; weird
	(global-set-key [select] [S-up])
)

#+END_SRC


* Editing
** Treesitter

#+BEGIN_SRC emacs-lisp tangle: yes
(use-package tree-sitter
	:ensure t
	:config
	;; activate tree-sitter on any buffer containing code for which it has a parser available
	(global-tree-sitter-mode)
	;; you can easily see the difference tree-sitter-hl-mode makes for python, ts or tsx
	;; by switching on and off
	(add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))

(use-package tree-sitter-langs
	:ensure t
	:after tree-sitter)
#+END_SRC

** Multiple Cursors                                                             :today:
	 Multi-cursor editing is so cool when you can do it. Useful when
	 editing many similar lines. More interactive than macros.
#+BEGIN_SRC emacs-lisp tangle: yes
(use-package multiple-cursors
	:bind (("M-c" . mc/edit-lines)
				 ("C->" . mc/mark-next-like-this)
				 ("C-<" . mc/mark-previous-like-this)
				 ("C-c C-<" . mc/mark-all-like-this)
				 ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

** Align lines on ' = '
#+BEGIN_SRC emacs-lisp tangle: yes
	(global-set-key (kbd "C-c =") 'align-eq)
#+END_SRC
** Revert a buffer
#+BEGIN_SRC emacs-lisp tangle: yes
	(global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC
** Unfill paragraphs
#+BEGIN_SRC emacs-lisp tangle: yes
	(defun unfill-paragraph ()
		"Takes a multi-line paragraph and makes it into a single line of text."
		(interactive)
		(let ((fill-column (point-max)))
			(fill-paragraph nil)))

	(global-set-key (kbd "M-Q") 'unfill-paragraph)
#+END_SRC
** Code Formatting
	:LOGBOOK:
	- State "MAYBE"      from "TODO"       [2019-02-13 Wed 10:37]
	:END:
*** Default Indentation
	 c-basic-offset is used by most major modes I use as the basis for
	 how deeply to indent any code.

	 #+BEGIN_SRC emacs-lisp tangle: yes
		 (setq c-basic-offset 1)
	 #+END_SRC
*** Whitespace
	I don't highlight trailing whitespace, because I auto-kill it anyway
#+BEGIN_SRC emacs-lisp tangle: yes
(setq-default show-trailing-whitespace nil)
#+END_SRC
	And here we do the killing
#+BEGIN_SRC emacs-lisp tangle: yes
(add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC
*** Tabs
#+BEGIN_SRC emacs-lisp tangle: yes
	(setq-default indent-tabs-mode t)
	(setq-default tab-width 2)
	(setq tab-width 2)
#+END_SRC
*** Add newline to the end of files
#+BEGIN_SRC emacs-lisp tangle: yes
	(setq require-final-newline t)
#+END_SRC
*** Set Unix file coding system
#+BEGIN_SRC emacs-lisp tangle: yes
	(setq-default buffer-file-coding-system 'utf-8-unix)
	(setq-default default-buffer-file-coding-system 'utf-8-unix)
	(set-default-coding-systems 'utf-8-unix)
	(prefer-coding-system 'utf-8-unix)
#+END_SRC

** LSP
*** TODO Basic
#+BEGIN_SRC emacs-lisp tangle: yes
	(use-package eglot :ensure t)
	;(use-package lsp-mode
	;  :config
	;  (setq
	;   lsp-ui-sideline-show-code-actions nil
	;   lsp-ui-sideline-show-hover nil
	;   lsp-highlight-symbol-at-point nil))
	;(use-package lsp-ui :commands lsp-ui-mode)
#+END_SRC

*** Claude Code
#+BEGIN_SRC emacs-lisp tangle: yes
  ;; for eat terminal backend:
  (use-package eat :ensure t)

  ;; install claude-code.el
  (use-package claude-code :ensure t
    :vc (:url "https://github.com/stevemolitor/claude-code.el" :rev :newest)
    :config (claude-code-mode)
    :bind-keymap ("C-c d" . claude-code-command-map))
#+END_SRC

*** Go Development
#+BEGIN_SRC emacs-lisp tangle: yes
  ;; Go mode with LSP and formatting
  (use-package go-mode
    :ensure t
    :mode "\\.go\\'"
    :hook ((go-mode . eglot-ensure)
	   (go-mode . (lambda ()
			(add-hook 'before-save-hook #'gofmt-before-save nil t))))
    :config
    ;; Use goimports for formatting (handles imports too)
    (setq gofmt-command "goimports"))

  ;; Configure Eglot for gopls
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs '(go-mode . ("gopls")))
    ;; Organize imports on save
    (add-hook 'go-mode-hook
	      (lambda ()
		(add-hook 'before-save-hook
			  (lambda ()
			    (call-interactively 'eglot-code-action-organize-imports))
			  nil t))))

  ;; Flycheck for additional linting
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode)
    :config
    ;; Only enable for programming modes
    (setq flycheck-global-modes '(not text-mode org-mode)))

  ;; Optional: Additional Go tools integration
  (use-package flycheck-golangci-lint
    :ensure t
    :after (flycheck go-mode)
    :hook (go-mode . flycheck-golangci-lint-setup)
    :config
    ;; Use golangci-lint for comprehensive linting
    (setq flycheck-golangci-lint-enable-all t))
#+END_SRC
What o

* Compilation
	If I'm compiling, just save all the buffers automatically for me
#+BEGIN_SRC emacs-lisp tangle: yes
	(setq compilation-ask-about-save nil)
#+END_SRC
	And make some nice hotkeys
#+BEGIN_SRC emacs-lisp tangle: yes
	(global-set-key (kbd "<f6>") 'compile)
	(global-set-key (kbd "<f7>") 'next-error) ;; can make this not global
#+END_SRC
And follow the output!!!
#+BEGIN_SRC emacs-lisp tangle: yes
	(setq compilation-scroll-output 'first-error)
#+END_SRC
** Colors

#+BEGIN_SRC emacs-lisp tangle: yes
(require 'ansi-color)

(defun colorize-compilation-buffer ()
	(toggle-read-only)
	(ansi-color-apply-on-region compilation-filter-start (point))
	(toggle-read-only))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

* Simple Behavior Customizations
** Set fill-column to sensible default for me

	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq fill-column 78)
	#+END_SRC

** Backups
	#+BEGIN_SRC emacs-lisp tangle: yes
		(defvar user-temporary-file-directory "~/tmp/saves/"
			(concat temporary-file-directory user-login-name "/"))

		(make-directory user-temporary-file-directory t)

		(setq
		 make-backup-files t

		 backup-by-copying t      ; don't clobber symlinks
		 backup-directory-alist
		 '(("." . user-temporary-file-directory))    ; don't litter my fs tree
		 delete-old-versions t
		 kept-new-versions 6
		 kept-old-versions 2
		 version-control t)       ; use versioned backups

		(setq vc-make-backup-files t)

		(setq backup-directory-alist
					`((".*" . ,user-temporary-file-directory)))
		(setq auto-save-file-name-transforms
					`((".*" ,user-temporary-file-directory t)))
		(setq auto-save-list-file-prefix
					(concat user-temporary-file-directory ".auto-saves-"))
#+END_SRC

** Text-mode is a better default than fundamental for me
	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq-default major-mode 'text-mode)
	#+END_SRC
** Replace 'yes/no' by just 'y/n'

	#+BEGIN_SRC emacs-lisp tangle: yes
		(fset 'yes-or-no-p 'y-or-n-p)
	#+END_SRC

** Tags operations should be case sensitive

	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq tags-case-fold-search nil)
	#+END_SRC

** Smooth Scrolling

	 https://www.emacswiki.org/emacs/SmoothScrolling

	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq scroll-step 1
					scroll-conservatively 10000
					mouse-wheel-scroll-amount '(1 ((shift) . 1))
					mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
					mouse-wheel-follow-mouse t) ;; scroll window under mouse
	 #+END_SRC

** Screen Splitting

	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq split-height-threshold 10000
					split-width-threshold 10000)
	#+END_SRC

** Subword movement in prog-mode

	#+BEGIN_SRC emacs-lisp tangle: yes
		(add-hook 'prog-mode-hook 'subword-mode)
	#+END_SRC

** No bell, thanks

	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq ring-bell-function 'ignore)
	#+END_SRC

** Disable warnings about large files
	I'm not afraid of large files, yo

	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq large-file-warning-threshold nil)
	#+END_SRC

** Search/Match should be case insensitive

	The documentation is actually a little misleading. The search will
	be case sensitive if the search string has any capital characters in
	it.

	#+BEGIN_SRC emacs-lisp tangle: yes
		(setq case-fold-search t)
	#+END_SRC

** Revert Files When They Change On Disk
#+BEGIN_SRC emacs-lisp tangle: yes
	(global-auto-revert-mode t)
#+END_SRC

** Make scripts executable on save
#+BEGIN_SRC emacs-lisp tangle: yes
(add-hook 'after-save-hook
					'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
* VC
** git-gutter-mode
#+BEGIN_SRC emacs-lisp tangle: yes
	(use-package git-gutter
		 :diminish git-gutter-mode
		 :commands (git-gutter-mode)
		 :bind (:map vc-prefix-map
								 ("[" . git-gutter:previous-hunk)
								 ("]" . git-gutter:next-hunk)
								 ("n" . git-gutter:revert-hunk)
								 ("SPC" . git-gutter:mark-hunk))
		 :init
		 (global-git-gutter-mode)
		 :config
		 (setq git-gutter:handled-backends '(git hg)))

	;; vc-hg comes with emacs, but we can still use use-package to group related
	;; config

	(use-package vc-hg
		:ensure nil
		:bind
		(:map vc-prefix-map
					("a" . vc-annotate)
					;; 'g' is the original binding for vc-annotate
					("g" . nil))
		:config
		(setq
		 vc-hg-annotate-re
		 (concat
			"^\\(?: *[^ ]+ +\\)?\\(D?[0-9]+\\) +" ;; user and revision
			"\\([0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]\\)" ;; date
			"\\(?: +\\([^:]+\\)\\)?:") ;; filename
		 vc-annotate-hg-switches "-u"
		 )
		;; redefine vc-hg-annotate-command to use -p (phabricator diff) instead of -n
		;; (revision number)
		;; TODO select -p or -n base on whether or not the hg repo is a phabricator
		;; project. Is there a better way to do this other than replacing the
		;; function, e.g. with advice?
		(defun vc-hg-annotate-command (file buffer &optional revision)
			"Execute \"hg annotate\" on FILE, inserting the contents in BUFFER.
	 Optional arg REVISION is a revision to annotate from."
			(apply #'vc-hg-command buffer 0 file "annotate" "-dq" "-p"
						 (append (vc-switches 'hg 'annotate)
										 (if revision (list (concat "-r" revision)))))))
#+END_SRC




* Modes
** Treesitter Grammars / Languages
Stolen from https://www.ovistoica.com/blog/2024-7-05-modern-emacs-typescript-web-tsx-config#orgb6fd011
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package tree-sitter
  	:mode (("\\.tsx\\'" . tsx-ts-mode)
	   ("\\.js\\'"  . typescript-ts-mode)
	   ("\\.mjs\\'" . typescript-ts-mode)
	   ("\\.mts\\'" . typescript-ts-mode)
	   ("\\.cjs\\'" . typescript-ts-mode)
	   ("\\.ts\\'"  . typescript-ts-mode)
	   ("\\.jsx\\'" . tsx-ts-mode)
	   ("\\.json\\'" .  json-ts-mode)
	   ("\\.Dockerfile\\'" . dockerfile-ts-mode)
	   ("\\.prisma\\'" . prisma-ts-mode))
    :hook
    (prog-mode . global-tree-sitter-mode)
    (tree-sitter-after-on . tree-sitter-hl-mode))

  (use-package tree-sitter-langs
    :after tree-sitter)

  (setq major-mode-remap-alist
  '((c-mode          . c-ts-mode)
    (c++-mode        . c++-ts-mode)
    (python-mode     . python-ts-mode)

    (typescript-mode . typescript-ts-mode)
    (js-mode         . typescript-ts-mode)
    (js2-mode        . typescript-ts-mode)

  	(tsx-mode        . tsx-ts-mode)
    (rust-mode       . rust-ts-mode)
    (go-mode         . go-ts-mode)
    (ruby-mode       . ruby-ts-mode)
    (java-mode       . java-ts-mode)
    (html-mode       . html-ts-mode)
    (css-mode        . css-ts-mode)
    (json-mode       . json-ts-mode)
    (yaml-mode       . yaml-ts-mode)
    (markdown-mode   . markdown-ts-mode)))
#+END_SRC

** ediff

Add a special command line switch to emacs so that we can easily use
emacs as our diff tool.

#+BEGIN_SRC bash
emacs -diff file1 file2
#+END_SRC

#+BEGIN_SRC emacs-lisp tangle: yes
  (defun command-line-diff (switch)
	(let ((file1 (pop command-line-args-left))
	  (file2 (pop command-line-args-left)))
		(ediff file1 file2)))

  (add-to-list 'command-switch-alist '("diff" . command-line-diff))

  (add-hook 'ediff-load-hook
	    (lambda ()
	      (message "getting my diff onnnnn")
	      (setq ediff-highlight-all-diffs nil)
	      (set-face-background
	       ediff-current-diff-face-A "#1e2424")
	      (set-face-background
	       ediff-current-diff-face-B "#1e2424")
	      (set-face-background
	       ediff-current-diff-face-C "#1e2424")
	      (make-face-italic
	       ediff-current-diff-face-A)
	      (make-face-italic
	       ediff-current-diff-face-B)
	      (make-face-italic
	       ediff-current-diff-face-C)))
#+END_SRC

** elisp
*** Turn on eldoc-mode
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package eldoc
	 :diminish eldoc-mode
	 :config (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+END_SRC

*** Enable slime-nav
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package elisp-slime-nav
	 :diminish elisp-slime-nav-mode
	 :config
	 (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t))))
#+END_SRC

*** Enable =rainbow-delimiters=
But only for emacs-lisp
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package rainbow-delimiters
	:config
	(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

*** package-lint for authoring packages
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package package-lint)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package markdown-mode
	:mode (("\\.text\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode)
	   ("README\\.md\\'" . gfm-mode)))
#+END_SRC

** YAML
Enable =yaml-mode=
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package yaml-mode
	:mode (("\\.lock$" . yaml-ts-mode)
	   ("\\.yml$" . yaml-ts-mode)
	   ("\\.yaml$" . yaml-ts-mode)))

#+END_SRC

** Protobuf
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package protobuf-mode
    :ensure t
    :mode "\\.proto\\'"
    :config
    (setq protobuf-mode-indent-level 2))
#+END_SRC

** Web Dev

Meat and potatoes
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package typescript-ts-mode
  	:mode (("\\.tsx\\'" . tsx-ts-mode)
	   ("\\.js\\'"  . typescript-ts-mode)
	   ("\\.mjs\\'" . typescript-ts-mode)
	   ("\\.mts\\'" . typescript-ts-mode)
	   ("\\.cjs\\'" . typescript-ts-mode)
	   ("\\.ts\\'"  . typescript-ts-mode)
	   ("\\.jsx\\'" . tsx-ts-mode))

  	:hook ((typescript-ts-mode . lsp-deferred)
	   (tsx-ts-mode . lsp-deferred))
  	)

  (use-package tide
    :ensure t
    :after (typescript-ts-mode company flycheck)
    :hook ((typescript-ts-mode . tide-setup)
	   (typescript-ts-mode . tide-hl-identifier-mode)
	   (tsx-ts-mode . tide-setup)
	   (tsx-ts-mode . tide-hl-identifier-mode))
    :config
    (setq tide-completion-detailed t
	  tide-always-show-documentation t))

  (use-package jest
    :ensure t
    :bind (:map typescript-ts-mode-map
		("C-c t j" . jest-popup))
    :config
    (setq jest-executable "pnpm test"))

  (use-package npm-mode
    :ensure t
    :hook ((typescript-ts-mode . npm-mode)
	   (tsx-ts-mode . npm-mode))
    :config
    (setq npm-mode-command-prefix "C-c n"))

  (use-package nodejs-repl
    :ensure t
    :bind (:map typescript-ts-mode-map
		("C-c r" . nodejs-repl)))

  (use-package add-node-modules-path
    :ensure t
    :hook ((typescript-ts-mode . add-node-modules-path)
	   (tsx-ts-mode . add-node-modules-path)))

#+END_SRC

Pug Templates for my JS misadventures
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package jade-mode
    :mode (("\\.pug\\'" . jade-mode))
    :config (add-hook 'jade-mode-hook 'indent-tabs-mode))
#+END_SRC

Prettier Formatting
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package apheleia
  	:ensure apheleia
  	:diminish ""
  	:defines
  	apheleia-formatters
  	apheleia-mode-alist
  	:functions
  	apheleia-global-mode
  	:config
  	(setf (alist-get 'prettier-json apheleia-formatters)
				'("prettier" "--stdin-filepath" filepath))
  	(apheleia-global-mode +1))
#+END_SRC

** C / C++
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package cc-mode
    :ensure nil  :hook
    ((c-mode . (lambda ()
							 (setq indent-tabs-mode nil)
							 (setq c-basic-offset 2)))
     (c++-mode . (lambda ()
								 (setq indent-tabs-mode nil)
								 (setq c-basic-offset 2))))
    :config
    ;; Example: bind go to definition to F12
    (define-key c-mode-base-map (kbd "<f12>") 'lsp-find-definition)
    (define-key c-mode-base-map (kbd "C-c h")  'lsp-describe-thing-at-point))
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package rust-mode
    :ensure t
    :bind (
	   ("C-c C-s" . rust-compile)
	   ("C-c C-t" . rust-test))
    :config
    (setq rust-format-on-save t)
	:hook (
				 rust-mode . (lambda ()
											 ;; Use spaces, not tabs
											 (setq indent-tabs-mode nil)
											 (setq tab-width 4))))

  (use-package cargo
    :ensure t
    :hook
    (rust-mode . cargo-minor-mode))

  (use-package toml-mode
    :ensure t
    :mode "\\.toml\\'")
 #+END_SRC

** Go
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package go-mode
    :ensure t
    :mode "\\.go\\'"
    :hook ((go-mode . lsp-deferred)
	   (go-mode . (lambda ()
			(setq indent-tabs-mode t)
			(setq tab-width 4))))
    :config
    (setq gofmt-command "gofumpt")
    (add-hook 'before-save-hook 'gofmt-before-save))

  (use-package go-tag
    :ensure t
    :bind (:map go-mode-map
		("C-c t a" . go-tag-add)
		("C-c t r" . go-tag-remove)))

  (use-package gotest
    :ensure t
    :bind (:map go-mode-map
		("C-c t f" . go-test-current-file)
		("C-c t t" . go-test-current-test)
		("C-c t p" . go-test-current-project)
		("C-c t b" . go-test-current-benchmark)))

  (use-package go-eldoc
    :ensure t
    :hook (go-mode . go-eldoc-setup))

  (use-package go-guru
    :ensure t
    :hook (go-mode . go-guru-hl-identifier-mode))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp tangle: yes
  (use-package python
    :ensure nil
      :mode ("\\.py\\'" . python-mode)
      :hook ((python-mode . (lambda ()
	 (setq indent-tabs-mode t)
	 (setq python-indent-offset 2)))
       (python-mode . tree-sitter-mode)
       (python-mode . tree-sitter-hl-mode))
      :config
      (setq python-shell-interpreter "python3"
      python-shell-interpreter-args "-i"))
#+END_SRC
