#+TITLE: Emacs Configuration
#+AUTHOR: John Allen
#+STARTUP: overview

* Package Installation
** Install use-package
   use-package is a really great way of managing and configuring your
   packages.

  1) deferred loading, faster startup
  2) dependency declaration is configuration I never include packages
     that I never use

  #+begin_src emacs-lisp :tangle yes
    (mapc
     (lambda (package)
       (if (not (package-installed-p package))
           (progn
             (package-refresh-contents)
             (package-install package))))
     '(use-package diminish bind-key delight))
  #+end_src

** Trigger use-package
   And force the install of missing packages.

  #+begin_src emacs-lisp :tangle yes
    (eval-when-compile
      (require 'use-package))
    (require 'diminish)
    (require 'bind-key)
    (require 'delight)
    (setq use-package-minimum-reported-time 0.01)
    (setq use-package-verbose t)
    (setq use-package-always-ensure t)
  #+end_src

* Use dash
  Because dash is awesome
  #+begin_src emacs-lisp :tangle yes
    (use-package dash)
  #+end_src
* Path Fix for Mac
  #+begin_src emacs-lisp :tangle yes
    (use-package exec-path-from-shell
      :if (memq window-system '(mac ns))
      :ensure t
      :config
      (exec-path-from-shell-initialize))
  #+end_src
* Customization File
  #+begin_src emacs-lisp :tangle yes
    (setq custom-file "custom.el")
    (load (concat config-load-path custom-file))
  #+end_src
* TODO Configure Helm
  Make everything fuzzy and also rebind functions.
  #+begin_src emacs-lisp :tangle yes
    (use-package flx)
    (use-package helm-flx)
    (use-package helm-descbinds)
    (use-package helm
      :demand
      :diminish helm-mode
      :bind (("M-x" . helm-M-x)
             ("M-y" . helm-show-kill-ring)
             ("C-x b" . helm-mini)
             ("C-x C-f" . helm-find-files)
             ("C-x r l" . helm-bookmarks)
             ("C-c C-i" . helm-semantic-or-imenu)
             :map helm-find-files-map ;; I like these from Ido
             ;; ("C-<tab>" . helm-execute-persistent-action)
             ("<tab>" . helm-execute-persistent-action)
             ("C-i" . helm-execute-persistent-action)
             ("C-<backspace>" . helm-find-files-up-one-level))
      :config
      (helm-mode 1)
      (helm-descbinds-mode)
      (helm-flx-mode +1)
      (setq helm-M-x-fuzzy-match t
            helm-buffers-fuzzy-matching t
            helm-recentf-fuzzy-match t
            helm-locate-fuzzy-match t
            helm-lisp-fuzzy-completion t
            helm-bookmark-show-location t))
  #+end_src
* Configuring =org-mode=
** Set environment
  #+begin_src emacs-lisp :tangle yes
    (setq org-directory "~/org/")

    (defun org-file-path (filename)
      "Return the absolute address of an org file, given its relative name."
      (concat (file-name-as-directory org-directory) filename))

    (defun org-find-file ()
      "Leverage Helm to quickly open any org files."
      (interactive)
      (find-file (concat org-directory
                         (helm-comp-read "Select your org file: "
                                         (directory-files org-directory nil "\.org$")))))
  #+end_src

** Modules
  #+begin_src emacs-lisp :tangle yes
    (setq-default
     org-modules
     '(org-bibtex
       org-crypt
       org-habit
       org-id
       org-info
       org-protocol))
    (require 'org-inlinetask)
  #+end_src

** Enable =org-mode= for org files
#+begin_src emacs-lisp :tangle yes
(use-package org
  :mode ("\\.org\\'" . org-mode)
  :mode ("\\.org_archive\\'" . org-mode))
#+end_src

** My typical TODO sequence
  #+begin_src emacs-lisp :tangle yes
    (setq
     org-todo-keywords
     '((sequence "TODO(t)" "MAYBE(m!)" "WAITING(w!)" "NEXT(n)" "STARTED(s)" "|" "DONE(d!)" "CANCELED(c@)")))
  #+end_src
** Pretty headlines
*** Make headlines more compact
#+begin_src emacs-lisp :tangle yes
  (setq org-hide-leading-stars t
        org-ellipsis "⤵"
        org-tags-column 80)
#+end_src
*** Start folded by default
#+begin_src emacs-lisp :tangle yes
    (setq org-startup-folded 'content)
#+end_src

*** Make all headline levels the same size
#+begin_src emacs-lisp :tangle yes
  (set-face-attribute 'org-level-1 nil :foreground "dodger blue" :weight 'bold :height 1.0)
  (set-face-attribute 'org-level-2 nil :foreground "#edd400" :weight 'bold :height 1.0)
#+end_src
** Enter follows links at point
   Because how the hell else should it work?
#+begin_src emacs-lisp :tangle yes
  (setq org-return-follows-link t)
#+end_src
** Src blocks
*** Intentation and fontification
#+begin_src emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+end_src

*** Just evaluate it, don't backtalk me
#+begin_src emacs-lisp :tangle yes
  (setq org-confirm-babel-evaluate nil)
#+end_src
** Set up global keys
#+begin_src emacs-lisp :tangle yes
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-iswitchb)
#+end_src
** Speed commands
#+begin_src emacs-lisp :tangle yes
  (setq org-use-speed-commands t)
#+end_src
** Enable =org-pomodoro=
  #+begin_src emacs-lisp :tangle yes
    (use-package org-pomodoro
      :config
      (setq org-pomodoro-start-sound-p t
            org-pomodoro-keep-killed-pomodoro-time t
            ; org-pomodoro-sound (expand-file-name "~/Dropbox/Audio/wav/13699__harri__a.mp3")
            ; org-pomodoro-short-break-sound (expand-file-name "~/Dropbox/Audio/wav/13699__harri__a.mp3")
            ; org-pomodoro-long-break-sound (expand-file-name "~/Dropbox/Audio/wav/13699__harri__a.mp3")
            ; org-pomodoro-start-sound (expand-file-name "~/Dropbox/Audio/wav/big-singing-bowl.wav")
            ; org-pomodoro-killed-sound (expand-file-name "~/Dropbox/Audio/wav/jf-glass-breaking.wav")
            org-pomodoro-time-format "%.2m"))
  #+end_src
** Notes file
#+begin_src emacs-lisp :tangle yes
(setq  org-default-notes-file (concat org-directory "/notes.org"))
#+end_src
** Agenda files
  #+begin_src emacs-lisp :tangle yes
    (setq jallen-org-habit-file (concat org-directory "habits.org")
          jallen-default-org-agenda-files
          (--map (concat org-directory it)
                 '("gtd.org" "work.org" "today.org" "5-min-journal.org"))
          org-agenda-files jallen-default-org-agenda-files)
  #+end_src
** Refiling
#+begin_src emacs-lisp :tangle yes
(setq org-outline-path-complete-in-steps nil
      org-refile-use-outline-path t
      org-refile-targets '((org-agenda-files :tag . "project")
                            ;; (nil . (:maxlevel . 1))
                           ))
#+end_src
** Configure projects
#+begin_src emacs-lisp :tangle yes
(setq org-stuck-projects '("+project" ("TODO" "NEXT") () "\\<IGNORE\\>" ))
(setq org-tags-exclude-from-inheritance '("project"))
#+end_src
** TODO Agenda configurations
#+begin_src emacs-lisp :tangle yes
    (setq
     org-agenda-custom-commands
     '(
       ;; ("w" todo "WAITING" nil ("waiting.txt"))
       ;; ("n" todo "NEXT" nil ("next.html"))
       ;; ("T" "Daily Action List"
       ;;  (
       ;;   (agenda "" ((org-agenda-ndays 1)
       ;;               (org-agenda-sorting-strategy
       ;;                (quote ((agenda time-up priority-down tag-up) )))
       ;;               (org-deadline-warning-days 0)
       ;;               ))))

       ("h" "Habits and Chores"
        ((agenda "" ((org-agenda-span 1)
                     (org-deadline-warning-days 30))))
        ((org-agenda-files (list jallen-org-habit-file))))
       ("n" "Work... work"
        ((tags-todo "today" ((org-agenda-overriding-header "Today's items")
                             (org-agenda-files jallen-default-org-agenda-files)))
         (agenda "" ((org-agenda-span 1)))
         (tags "project" ((org-agenda-files '("~/org/work.org"))
                          (org-agenda-overriding-header "Work Projects")))
         (todo "NEXT" ((org-agenda-files '("~/org/work.org"))
                       (org-agenda-overriding-header "Work Next Items")))
         (tags "project" ((org-agenda-files '("~/org/gtd.org"))
                          (org-agenda-overriding-header "Personal Projects")))
         (todo "NEXT" ((org-agenda-files '("~/org/gtd.org"))
                       (org-agenda-overriding-header "Personal Next Items")))
         (tags-todo "inbox" ((org-agenda-files '("~/org/gtd.org"))
                             (org-agenda-overriding-header "Inbox")))
         )
        ((org-agenda-files '("~/org/work.org"))))

       ("D" "Daily Action List"
        ((agenda "habits" ((org-agenda-files '("~/org/habits.org"))))
         (agenda "" ((org-agenda-span 1)
                     (org-agenda-sorting-strategy
                      (quote ((agenda time-up priority-down tag-up) )))
                     (org-deadline-warning-days 0)
                     ))))

       ("d" "Agenda + Next Actions"
        ((agenda "honker" ((org-agenda-span 1)
                           (org-agenda-sorting-strategy
                            (quote ((agenda time-up priority-down tag-up) )))
                           (org-deadline-warning-days 0)
                           ))
         (todo "NEXT")) nil ("next.html"))

       ("w" "Weekly Agenda + Next Actions"
        ((agenda "weekly" ((org-agenda-span 7)
                           (org-agenda-sorting-strategy
                            (quote ((agenda time-up priority-down tag-up) )))
                           (org-deadline-warning-days 0)
                           ))
         (todo "NEXT"))
        nil ("week.html"))

       ("W" "Weekly Review"
        ((agenda "" ((org-agenda-span 7))) ;; review upcoming deadlines and appointments
         ;; type "l" in the agenda to review logged items
         (stuck "") ;; review stuck projects as designated by org-stuck-projects
         (tags "project") ;; review all projects
         (todo "MAYBE") ;; review someday/maybe items
         (todo "WAITING"))) ;; review waiting items
       ))
#+end_src
** Agenda faces

   #+begin_src emacs-lisp :tangle yes
     (defface my-org-deadline-yesterday
       '((t (:foreground "#F45B69" :weight bold)))
       "Agenda deadlines overdue")
     (defface my-org-deadline-today
       '((t (:foreground "#FAFFFD" :weight bold)))
       "Agenda deadlines iminent")
     (defface my-org-deadline-tomorrow
       '((t (:foreground "#9FD356")))
       "Agenda deadlines soon")
     (defface my-org-deadline-later
       '((t (:foreground "#3C91E6")))
       "Agenda deadlines far in the future")
     (defface my-org-deadline-someday
       '((t (:foreground "#0A2463")))
       "Agenda deadlines far in the future")

     ;; faces for showing deadlines in the agenda
     (setq org-agenda-deadline-faces
           '((1.01 . my-org-deadline-yesterday)
             (0.99 . my-org-deadline-today)
             (0.69 . my-org-deadline-tomorrow)
             (0.49 . my-org-deadline-later)
             (0.00 . my-org-deadline-someday)))

   #+end_src
** Clocks
*** Logging time of task completion
#+begin_src emacs-lisp :tangle yes
  (setq org-log-done 'time ; log the time a task is marked done
        org-log-into-drawer t) ; timestamps go in a drawer, not the body
#+end_src
*** Logging time spent on tasks
#+begin_src emacs-lisp :tangle yes
  (setq org-clock-into-drawer t
        org-clock-out-remove-zero-time-clocks t)
#+end_src
*** Editing timestamps
#+begin_src emacs-lisp :tangle yes
  (setq org-edit-timestamp-down-means-later t)
#+end_src
*** Save the running clock and all clock history when exiting Emacs, load it on startp
#+begin_src emacs-lisp :tangle yes
  (org-clock-persistence-insinuate)
  (setq org-clock-persist 'history)
  (setq org-clock-in-resume t)
#+end_src
*** Update the state of tasks when they get clocked
#+begin_src emacs-lisp :tangle yes
(setq org-clock-in-switch-to-state "STARTED")
#+end_src
*** Show clocked in task in header-line
#+begin_src emacs-lisp :tangle yes
(defun jallen-show-org-clock-in-header-line ()
  (setq-default header-line-format '((" " org-mode-line-string " "))))

(defun jallen-hide-org-clock-from-header-line ()
  (setq-default header-line-format nil))

(add-hook 'org-clock-in-hook
          #'jallen-show-org-clock-in-header-line)
(add-hook 'org-clock-out-hook
          #'jallen-hide-org-clock-from-header-line)
(add-hook 'org-clock-cancel-hook
          #'jallen-hide-org-clock-from-header-line)
#+end_src
** =org-capture= templates
#+begin_src emacs-lisp :tangle yes
  (setq
   org-capture-templates
   '(
     ("t" "Todo" entry ; New inbox item to be processed
      (file+headline "~/org/gtd.org" "Inbox")
      "* TODO %?\n  %i\n")

     ("T" "Today" entry ; New inbox item to be processed
      (file+headline "~/org/today.org" "todo list")
      "* TODO %?   :today:\n  %i\n")

     ("p" "Project" entry ; Create a new project entry
      (file+headline "~/org/gtd.org" "Projects")
      "* %? :project:\n  %i\n")

     ("a" "Action" entry ; New inbox item to be processed
      (file+datetree "~/org/gtd.org" "Inbox")
      "* TODO %? :action:\n  %i\n")

     ("j" "Journal Entries")
     ("jm" "Precious Memory" entry ; Freeform journal entry
      (file+datetree "~/org/journal.org")
      "* %? :memory:\n  %i\n  %a")
     ("jl" "Today I Learned" entry ; Breif TIL journal entry
      (file+datetree "~/org/journal.org" "TIL")
      "* %?\nLearned on %U :til:\n  %i\n  %a")
     ("j." "Journal" entry ; Freeform journal entry
      (file+datetree "~/org/journal.org")
      "* %?\nEntered on %U\n  %i\n  %a")

     ("5" "5 Minute Journal")
     ("5m" "Morning Entry" entry (file+datetree "~/org/5-min-journal.org")
      "* Morning\n  I am grateful for...\n  - %?\n  - \n  - \n\n  What will I do to make today great?\n  - \n  - \n  - \n\n  I am ...")
                                          ; 5-minute journal. Evening entry
     ("5e" "Evening Entry" entry (file+datetree "~/org/5-min-journal.org")
      "* Evening\n  3 amazing things that happened today...\n  - %?\n  - \n  - \n\n  How could I have made today even better?\n  - \n")

     ("f" "CBT" entry (file "~/org/cbt-journal.org")
      "* %U\n** Activating Event\n** thoughts/Beliefs\n** emotional Consequences\n")

     ("n" "notes" entry ; Generic notebook entry
      (file+datetree "~/org/notes.org")
      "* %? %U\n")
     ))
 #+end_src
** Habits
#+begin_src emacs-lisp :tangle yes
  (require 'org-habit)
  (setq org-habit-preceding-days 7
          org-habit-following-days 1
          org-habit-show-habits-only-for-today t
          org-habit-graph-column 52
          org-habit-show-all-today nil)
#+end_src
** Auto habit tracking for 5-min-journal
   The ids in here are hardcoded the the random ids in my habits.org
  #+begin_src emacs-lisp :tangle yes
    (defun 5-min-journal-complete-on-capture ()
      "To be run in org-capture-before-finalize-hook"
      (pcase (plist-get org-capture-current-plist :description)
        ("Morning Entry"
         (progn
           (org-id-goto "FEE1A918-0FFE-446F-A954-5B7A6DE29D3F")
           (org-todo "DONE")
           (bury-buffer)))
        ("Evening Entry"
         (progn
           (org-id-goto "81125689-466F-4C87-9898-FB344CDD175F")
           (org-todo "DONE")
           (bury-buffer)))
        (_ (message "Capture complete!")))
      )
    (add-hook
     'org-capture-before-finalize-hook
     '5-min-journal-complete-on-capture)
  #+end_src
** Working with agendas
*** Highlight the line that the point is on
#+begin_src emacs-lisp :tangle yes
  (add-hook 'org-agenda-finalize-hook (lambda () (hl-line-mode)))
#+end_src
*** Buffer setup
  #+begin_src emacs-lisp :tangle yes
    (setq org-agenda-use-time-grid nil
          org-agenda-restore-windows-after-quit t
          org-agenda-start-on-weekday nil
          org-agenda-span 1
          org-agenda-window-setup 'current-window)
  #+end_src
*** org-goto should use a narrowed view
    I find this much more readable
    #+begin_src emacs-lisp :tangle yes
      (advice-add 'org-agenda-goto :after
                  (lambda (&rest args)
                    (org-narrow-to-subtree)))
    #+end_src
*** Hotkeys
#+begin_src emacs-lisp :tangle yes
  (add-hook
   'org-agenda-mode-hook
   (lambda ()
     (define-key org-agenda-mode-map "q" 'bury-buffer)
     (define-key org-agenda-mode-map "P" 'org-pomodoro))
   'append)
#+end_src
*** My =:today:= tag
#+begin_src emacs-lisp :tangle yes
  (defun org-toggle-today ()
    (interactive)
    (org-toggle-tag "today"))
  (define-key org-mode-map (kbd "C-c T") 'org-toggle-today)
#+end_src
** Exporting
*** Exporter Setup
#+begin_src emacs-lisp :tangle yes
  (setq
   org-export-html-style-include-scripts nil
   org-export-html-style-include-default nil
   org-export-backends '(ascii beamer html icalendar texinfo latex)
   org-publish-use-timestamps-flag nil)
#+end_src
*** HTML postamble
#+begin_src emacs-lisp :tangle yes
  (setq org-html-postamble-format
        (quote
         (("en" "<p class=\"author\">Author: %a (%e)</p>
  powered by <p class=\"creator\">%c</p><p class=\"validation\">%v</p>"))))
#+end_src

** FB Tasks links
#+begin_src emacs-lisp :tangle yes
  (org-add-link-type "task" 'org-task-open)

  (defun org-task-open (path)
    "Open the task in the browser."
    (browse-url (concat "https://our.intern.facebook.com/intern/tasks/?q=" path)))
#+end_src
* Snippets
  Snippets are are awesome. They are found in ~/emacs.d/snippets
#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :diminish yas-minor-mode
  :config (yas-global-mode 1))
#+end_src
* Navigation
** Smooth Scrolling
(use-package smooth-scrolling
  :config
  (smooth-scrolling-mode 1)
  (setq smooth-scroll-margin 5))
** Configure Windmove
   I like to use the S-<arrow> keys for moving windows
#+begin_src emacs-lisp :tangle yes
(windmove-default-keybindings)

;; Make windmove work in org-mode:
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src

** Manipulate Window Sizes
   C-x <arrow>
#+begin_src emacs-lisp :tangle yes
(global-set-key
 (kbd "C-x <right>")
 '(lambda () (interactive) (enlarge-window-horizontally 4)))
(global-set-key
 (kbd "C-x <left>")
 '(lambda () (interactive) (shrink-window-horizontally 4)))
(global-set-key
 (kbd "C-x <up>")
 '(lambda () (interactive) (enlarge-window 4)))
(global-set-key
 (kbd "C-x <down>")
 '(lambda () (interactive) (shrink-window 4)))
#+end_src
** Popwin
  Popwin give us special temporary behavior for certain buffers. This
  lets them pop in and out in a way that I like better than the
  default behavior of taking over the other-buffer

#+begin_src emacs-lisp :tangle yes
(use-package popwin
  :config
  (setq display-buffer-function 'popwin:display-buffer)
  (setq popwin:special-display-config
      (quote
       (("*Ibuffer*" :position top :noselect t :height 30)
        ("*Python Check*" :position top :noselect t :height 30)
        ("*magit-log*")
        ("*compilation*")
        ("*Python Doc*")
        ("*grep*")
        ("*Help*")
        ("*hh-client-definitions*" :noselect t)
        ("*Completions*" :noselect t)
        ("*Occur*" :noselect t)))))
#+end_src

** Go to a line by number
   I'm not really sure why this isn't bound somewhere already... I use
   this all the time. Am I the weird one?
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c t")  'goto-line)
#+end_src
** Enable win-switch
Super nice to switch between frames and buffers
#+begin_src emacs-lisp :tangle yes
(use-package win-switch
  :bind (("C-x o" . win-switch-dispatch))
  :config
  (setq win-switch-provide-visual-feedback t)
  (setq win-switch-feedback-background-color "purple")
  (setq win-switch-feedback-foreground-color "white")
  (win-switch-setup-keys-default))
#+end_src
** Enable ibuffer
#+begin_src emacs-lisp :tangle yes
(use-package ibuffer-vc)
(use-package ibuffer-git)
(define-key global-map (kbd "C-x C-b") 'ibuffer)
(setq ibuffer-default-sorting-mode 'major-mode)
;; (define-key
;;   ibuffer-mode-map
;;   (kbd "RET")
;;   'ibuffer-visit-buffer-other-window)

#+end_src
** Enable minimap
#+begin_src emacs-lisp :tangle yes
(use-package minimap
  :config
  (setq minimap-window-location "right")
  (setq minimap-major-modes '(prog-mode org-mode)))
#+end_src
** Enable =anzu=
#+begin_src emacs-lisp :tangle yes
(use-package anzu
  :config (global-anzu-mode +1)
  (setq anzu-mode-lighter ""))
#+end_src

** Save Point Positions Between Sessions
#+begin_src emacs-lisp :tangle yes
(use-package saveplace
  :config
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" "~/tmp/saves")))
#+end_src
** TODO The Silver Searcher
   Maybe install/enable this only if ag is in the path
#+begin_src emacs-lisp :tangle yes

(use-package ag)
#+end_src
* Appearance
** Frame Titles
#+begin_src emacs-lisp :tangle yes
(setq frame-title-format (concat  "%b - emacs@" system-name))
#+end_src
** Fonts
 Install fonts from my .emacs.d into system locations
#+begin_src emacs-lisp :tangle yes
(defun jallen-install-font ()
  "copy my font files into the system-specific location"
  (let ((fonts-source "~/.emacs.d/Input_Fonts/"))
    (if (string-equal system-type "darwin")
        (copy-directory fonts-source "~/Library/Fonts/") ; Mac
      (copy-directory fonts-source "~/.fonts/") ; Linux
      )
    ))

(add-hook 'before-make-frame-hook
          (lambda ()
            (if (-any '(lambda (fonts) (string-prefix-p "-*-Input " (elt fonts 6))) (x-family-fonts))
                (jallen-install-font))))
#+end_src

Define some shortcuts for sizes that I use sometimes
#+begin_src emacs-lisp :tangle yes
(defun jallen-font () (interactive)
       (set-frame-font "Input Mono Narrow-16"))
(defun jallen-font-no-contacts () (interactive)
       (set-frame-font "Input Mono Narrow-22"))
(defun jallen-blind () (interactive)
       (set-frame-font "Input Mono Narrow-30"))
#+end_src
** Frame Configuration
#+begin_src emacs-lisp :tangle yes
(setq default-frame-alist
      (quote
       ((left-fringe . 1)
        (right-fringe . 1)
        (menu-bar-lines . 0)
        (tool-bar-lines . 0)
        (font . "Input Mono Narrow-16")
        )))
#+end_src
** Theme
   I love tangotango
#+begin_src emacs-lisp :tangle yes
(use-package tangotango-theme
  :config (load-theme 'tangotango t))
#+end_src
** Uniqify Buffer Names
   TODO make this lazy load maybe?
#+begin_src emacs-lisp :tangle yes
(require 'uniquify)
(setq uniquify-buffer-name-style 'reverse
      uniquify-separator "|"
      uniquify-after-kill-buffer-p t
      uniquify-ignore-buffers-re "^\\*")
#+end_src
** isearch faces
#+begin_src emacs-lisp :tangle yes
  (set-face-foreground 'lazy-highlight "black")
  (set-face-background 'lazy-highlight "yellow")
  (set-face-foreground 'isearch "white")
  (set-face-background 'isearch "blue")
#+end_src
** Turn off nux and noisy UI
   No scroll, tool, menu bars
#+begin_src emacs-lisp :tangle yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+end_src

   Scratch buffer can just be empty, thanks
#+begin_src emacs-lisp :tangle yes
  (setq initial-scratch-message nil)
#+end_src

   No NUX
#+begin_src emacs-lisp :tangle yes
  (setq inhibit-splash-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+end_src

** Show lines and columns
#+begin_src emacs-lisp :tangle yes
(setq line-number-mode t
      column-number-mode t)
#+end_src
* Terminal Configuration
** Fix my shell prompt regex
   I use fancy unicode characters in my shell prompt

** Terminals in emacs should use ansi colors
#+begin_src emacs-lisp :tangle yes
(use-package ansi-color)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
(setq comint-prompt-read-only t)
#+end_src

** Deal with running emacs in terminal
   Here is some scar tissue of me trying to make all keys work in the
terminal as they do in X11. This isn't possible as far as I can tell,
and I'm no longer sure if this does anything for me.

we are expecting an xterm compatible terminal here. tmux requires you
to set xterm-mode as a terminal option for this

#+begin_src emacs-lisp :tangle yes
(defadvice terminal-init-xterm (after map-S-up-escape-sequence activate)
  (define-key input-decode-map "\e[1;9A" [M-up])
  (define-key input-decode-map "\e[1;9B" [M-down])
  (define-key input-decode-map "\e[1;9C" [M-right])
  (define-key input-decode-map "\e[1;9D" [M-left])

  (define-key input-decode-map "\e[1;10A" [M-S-up])
  (define-key input-decode-map "\e[1;10B" [M-S-down])
  (define-key input-decode-map "\e[1;10C" [M-S-right])
  (define-key input-decode-map "\e[1;10D" [M-S-left])

  ;; weird
  (global-set-key [select] [S-up])
)

#+end_src

* Dired
** Enable =dired-x=
#+begin_src emacs-lisp :tangle yes
(require 'dired-x)
#+end_src

** Simple =dired= display
#+begin_src emacs-lisp :tangle yes
(use-package dired-details
  :config
  (setq-default dired-details-hidden-string "--- ")
  (dired-details-install))
#+end_src

* RSS Reader
** Basic setup
   #+begin_src emacs-lisp :tangle yes
     (setq newsticker-date-format "(%A %D %H:%M)"
           newsticker-html-renderer 'shr-render-region
           newsticker-use-full-width nil)

   #+end_src
** Set up HTML rendering
   #+begin_src emacs-lisp :tangle yes
     (use-package w3m
       :if (executable-find "w3m")
       :init
       (setq newsticker-html-renderer 'w3m-region)
       )
   #+end_src
** List of blogs
   #+begin_src emacs-lisp :tangle yes
     (global-set-key (kbd "C-c C-n") 'newsticker-show-news)
     (setq-default
      newsticker-url-list
      '(("Schneier on Security" "https://www.schneier.com/blog/atom.xml" nil nil nil)
        ("Xah Emacs Blog" "http://ergoemacs.org/emacs/blog.xml" nil nil nil)
        ("Arabesque" "https://sanctum.geek.nz/arabesque/feed/" nil nil nil)
        ("Sacha Chua" "http://sachachua.com/blog/feed/" nil nil nil)))
   #+end_src
* Disable warnings about large files
  I'm not afraid of large files, yo
#+begin_src emacs-lisp :tangle yes
(setq large-file-warning-threshold nil)
#+end_src
* Highlight the selected region
#+begin_src emacs-lisp :tangle yes
(setq transient-mark-mode t)
#+end_src
* Search/Match should be case insensitive
  The documentation is actually a little misleading. The search will
  be case sensitive if the search string has any capital characters in
  it.
#+begin_src emacs-lisp :tangle yes
(setq case-fold-search t)
#+end_src
* Revert Files When They Change On Disk
#+begin_src emacs-lisp :tangle yes
(global-auto-revert-mode t)
#+end_src
* Simple Behavior Customizations
** Set fill-column to sensible default for me
#+begin_src emacs-lisp :tangle yes
(setq fill-column 78)
#+end_src
** Backups
#+begin_src emacs-lisp :tangle yes
(defvar user-temporary-file-directory "~/tmp/saves/"
  (concat temporary-file-directory user-login-name "/"))
(make-directory user-temporary-file-directory t)

(setq
 make-backup-files t
 backup-by-copying t      ; don't clobber symlinks
 backup-directory-alist
 '(("." . user-temporary-file-directory))    ; don't litter my fs tree
 delete-old-versions t
 kept-new-versions 6
 kept-old-versions 2
 version-control t)       ; use versioned backups

; disable vc integration, the repos can just be too big
(setq vc-handled-backends nil)
(setq vc-make-backup-files t)

(setq backup-directory-alist
      `((".*" . ,user-temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,user-temporary-file-directory t)))
(setq auto-save-list-file-prefix
      (concat user-temporary-file-directory ".auto-saves-"))

#+end_src

** Text-mode is a better default than fundamental for me
#+begin_src emacs-lisp :tangle yes
(setq-default major-mode 'text-mode)
#+end_src
** Replace 'yes/no' by just 'y/n'
#+begin_src emacs-lisp :tangle yes
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Tags operations should be case sensitive
#+begin_src emacs-lisp :tangle yes
(setq tags-case-fold-search nil)
#+end_src

** Smooth Scrolling
   https://www.emacswiki.org/emacs/SmoothScrolling
   #+begin_src emacs-lisp :tangle yes
   (setq scroll-step 1
         scroll-conservatively 10000
         mouse-wheel-scroll-amount '(1 ((shift) . 1))
         mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
         mouse-wheel-follow-mouse t) ;; scroll window under mouse
   #+end_src
** Screen Splitting
#+begin_src emacs-lisp :tangle yes
(setq split-height-threshold 10000
      split-width-threshold 10000)
#+end_src
** Subword movement in prog-mode
#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'subword-mode)
#+end_src
** No bell, thanks
#+begin_src emacs-lisp :tangle yes
(setq ring-bell-function 'ignore)
#+end_src
* Spellcheck in Comments & Strings
#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src
* Editing
** Multiple Cursors
   Multi-cursor editing is so cool when you can do it. Useful when
   editing many similar lines. More interactive than macros.
#+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind (("M-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)
         ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+end_src

** Align lines on ' = '
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c =") 'align-eq)
#+end_src
** Revert a buffer
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c r") 'revert-buffer)
#+end_src
* Magit
  Magit is a great interface to git. Too bad we don't have one for
  mercurial
  #+begin_src emacs-lisp :tangle yes
  (use-package magit
    :bind ("C-x g" . magit-status))
  #+end_src
* Flycheck

#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :diminish
    :config
    (setq-default flycheck-temp-prefix ".flycheck")
    (setq-default flycheck-disabled-checkers
                  '(emacs-lisp-checkdoc
                    python-flake8
                    json-jsonlist)))
#+end_src

* Awesome Key Bindings
** Multiple Cursors
#+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind
  (("M-c" . mc/edit-lines)
   ("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-c C-<" . mc/mark-all-like-this)))
#+end_src

* Utility Functions
** Read lines of file into a list
#+begin_src emacs-lisp :tangle yes
(defun jallen-read-lines (fpath)
  "Return a list of lines of a file at at FPATH."
  (with-temp-buffer
    (insert-file-contents fpath)
    (split-string (buffer-string) "\n" t)))
#+end_src
** Edit Current Buffer As root
#+begin_src emacs-lisp :tangle yes
(defun sudo ()
  "Use TRAMP to `sudo' the current buffer"
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+end_src
** Sticky Window
  Sometimes I like having a dedicated buffer for compilation output or
  other things

#+begin_src emacs-lisp :tangle yes
(defun windstick (&optional n)
  (interactive "P")
  (set-window-dedicated-p (selected-window) t))

(defun windrelease (&optional n)
  (interactive "P")
  (set-window-dedicated-p (selected-window) nil))
#+end_src

** Sort Lines In Paragraph
#+begin_src emacs-lisp :tangle yes
(defun jallen-sort-para ()
  "Sorts the paragraph in which the point is located"
  (interactive)
  (save-excursion
    (let (bpoint epoint)
      (backward-paragraph)
      (setq bpoint (point))
      (forward-paragraph)
      (setq epoint (point))
      (sort-lines nil bpoint epoint)
      )
    ))
#+end_src
** Increment/Decrement number at point
   Because why not?
#+begin_src emacs-lisp :tangle yes
(defun increment-number-at-point ()
  (interactive)
  (skip-chars-backward "0-9")
  (or (looking-at "[0-9]+")
      (error "No number at point"))
  (replace-match (number-to-string (1+ (string-to-number (match-string 0))))))

(defun decrement-number-at-point ()
  (interactive)
  (skip-chars-backward "0-9")
  (or (looking-at "[0-9]+")
      (error "No number at point"))
  (replace-match (number-to-string (- (string-to-number (match-string 0)) 1))))
#+end_src
* Compilation
  If I'm compiling, just save all the buffers automatically for me
#+begin_src emacs-lisp :tangle yes
(setq compilation-ask-about-save nil)
#+end_src

* Code Format
** Default Indentation
   c-basic-offset is used by most major modes I use as the basis for
   how deeply to indent any code.
#+begin_src emacs-lisp :tangle yes
(setq c-basic-offset 2)
#+end_src
** Whitespace
  I don't highlight trailing whitespace, because I auto-kill it anyway
#+begin_src emacs-lisp :tangle yes
(setq-default show-trailing-whitespace nil)
#+end_src
  And here we do the killing
#+begin_src emacs-lisp :tangle yes
(add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src
** Tabs
#+begin_src emacs-lisp :tangle yes
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
(setq tab-width 2)
#+end_src
** Add newline to the end of files
#+begin_src emacs-lisp :tangle yes
(setq require-final-newline t)
#+end_src
** Set Unix file coding system
#+begin_src emacs-lisp :tangle yes
(setq-default buffer-file-coding-system 'utf-8-unix)
(setq-default default-buffer-file-coding-system 'utf-8-unix)
(set-default-coding-systems 'utf-8-unix)
(prefer-coding-system 'utf-8-unix)
#+end_src
* Better regex-builder
  'string' does not require the crazy double escape thing from emacs
  regexes
#+begin_src emacs-lisp :tangle yes
(use-package re-builder
  :config
  (setq reb-re-syntax 'string))
#+end_src
* Make scripts executable on save
#+begin_src emacs-lisp :tangle yes
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src
* echo-keys
  This is useful for screen capture videos
  #+begin_src emacs-lisp :tangle yes
    (defvar *echo-keys-last* nil "Last command processed by `echo-keys'.")

    (defun echo-keys ()
      (interactive)
      (let ((deactivate-mark deactivate-mark))
        (when (this-command-keys)
          (with-current-buffer (get-buffer-create "*echo-key*")
            (goto-char (point-max))
            ;; self  self
            ;; self  other \n
            ;; other self  \n
            ;; other other \n
            (unless (and (eq 'self-insert-command *echo-keys-last*)
                         (eq 'self-insert-command this-command))
              (insert "\n"))
            (if (eql this-command 'self-insert-command)
                (let ((desc (key-description (this-command-keys))))
                  (if (= 1 (length desc))
                      (insert desc)
                    (insert " " desc " ")))
              (insert (key-description (this-command-keys))))
            (setf *echo-keys-last* this-command)
            (dolist (window (window-list))
              (when (eq (window-buffer window) (current-buffer))
                ;; We need to use both to get the effect.
                (set-window-point window (point))
                (end-of-buffer)))))))

    (defun toggle-echo-keys ()
      (interactive)
      (if (member 'echo-keys  pre-command-hook)
          (progn
            (remove-hook 'pre-command-hook 'echo-keys)
            (dolist (window (window-list))
              (when (eq (window-buffer window) (get-buffer "*echo-key*"))
                (delete-window window))))
        (progn
          (add-hook    'pre-command-hook 'echo-keys)
          (delete-other-windows)
          (split-window nil (- (window-width) 32) t)
          (other-window 1)
          (switch-to-buffer (get-buffer-create "*echo-key*"))
          (set-window-dedicated-p (selected-window) t)
          (other-window 1))))
  #+end_src
* LSP
** Basic
#+BEGIN_SRC emacs-lisp tangle: yes
  (add-to-list 'load-path "/home/jallen/oss/lsp-mode")
  (add-to-list 'load-path "/home/jallen/oss/lsp-hack")
  (require 'lsp-mode)
  (require 'lsp-common)
  (require 'lsp-hack)
  ; such alpha
  ; (add-hook 'hack-mode-hook #'lsp-hack-enable)
#+END_SRC

* Modes
** elisp
*** Turn on eldoc-mode
   #+begin_src emacs-lisp :tangle yes
   (use-package eldoc
     :diminish eldoc-mode
     :config (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
   #+end_src

*** Enable slime-nav
   #+begin_src emacs-lisp :tangle yes
     (use-package elisp-slime-nav
       :diminish elisp-slime-nav-mode
       :config
       (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t))))
   #+end_src
*** Enable =rainbow-delimiters=
    But only for emacs-lisp
    #+begin_src emacs-lisp :tangle yes
    (use-package rainbow-delimiters
      :config
      (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
    #+end_src

** CSS
#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode :delight)
(use-package css-mode
  :mode "\\.css$"
  :config
  (setq css-indent-level 2
        css-indent-offset 2)
  (add-hook 'css-mode-hook 'rainbow-mode)
)
#+end_src
** C++
#+begin_src emacs-lisp :tangle yes
(use-package google-c-style)
#+end_src

Tweaks to support enums better
#+begin_src emacs-lisp :tangle yes
(defun inside-class-enum-p (pos)
  "Checks if POS is within the braces of a C++ \"enum class\"."
  (ignore-errors
    (save-excursion
      (goto-char pos)
      (up-list -1)
      (backward-sexp 1)
      (looking-back "enum[ \t]+class[ \t]+[^}]+"))))

(defun align-enum-class (langelem)
  (if (inside-class-enum-p (c-langelem-pos langelem))
      0
    (c-lineup-topmost-intro-cont langelem)))

(defun align-enum-class-closing-brace (langelem)
  (if (inside-class-enum-p (c-langelem-pos langelem))
      '-
    '+))

(defun fix-enum-class ()
  "Setup `c++-mode' to better handle \"class enum\"."
  (add-to-list 'c-offsets-alist
               '(topmost-intro-cont . align-enum-class))
  (add-to-list 'c-offsets-alist
               '(statement-cont . align-enum-class-closing-brace)))
#+end_src


#+begin_src emacs-lisp :tangle yes
(use-package cpp
  :diminish c++-mode
  :mode "\\.h$"
  :bind (:map c++-mode-map
         ("C-c o" . ff-get-other-file))
  :config
  (add-hook 'c++-mode-hook 'fix-enum-class)
  (add-hook 'c++-mode-hook
            (lambda ()
              (subword-mode 1)
              (setq-local require-final-newline t)
              (setq-local compilation-auto-jump-to-first-error t)
              ))
  (add-hook 'c-mode-common-hook 'google-set-c-style)
  (add-hook 'c-mode-common-hook 'google-make-newline-indent))
#+end_src

** ediff

Add a special command line switch to emacs so that we can easily use
emacs as our diff tool.

#+BEGIN_SRC bash
emacs -diff file1 file2
#+END_SRC

#+begin_src emacs-lisp :tangle yes
(defun command-line-diff (switch)
  (let ((file1 (pop command-line-args-left))
        (file2 (pop command-line-args-left)))
    (ediff file1 file2)))

(add-to-list 'command-switch-alist '("diff" . command-line-diff))

(add-hook 'ediff-load-hook
          (lambda ()
            (message "getting my diff onnnnn")
            (flycheck-mode nil)
            (setq ediff-highlight-all-diffs nil)
            (set-face-background
             ediff-current-diff-face-A "#1e2424")
            (set-face-background
             ediff-current-diff-face-B "#1e2424")
            (set-face-background
             ediff-current-diff-face-C "#1e2424")
            (make-face-italic
             ediff-current-diff-face-A)
            (make-face-italic
             ediff-current-diff-face-B)
            (make-face-italic
             ediff-current-diff-face-C)))
#+end_src
** YAML
   Enable =yaml-mode=
#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
  :mode ("\\.yml$" "\\.yaml$" "\\.lock$")
  :config
  (add-hook 'yaml-mode-hook 'flycheck-mode)
  (add-hook 'yaml-mode-hook 'flyspell-mode))
#+end_src
** Python
   In the past I've used elpy to great effect, but I haven't messed
   with that in a while
*** Setup =python-mode=
   #+begin_src emacs-lisp :tangle yes
   (add-hook 'python-mode-hook 'electric-operator-mode)
   (setq python-shell-interpreter "/usr/bin/ipython")
   (setq py-basic-offset 4)
   #+end_src
*** Enable company-jedi
   #+begin_src emacs-lisp :tangle yes
   (use-package company-jedi
     :config (add-to-list 'company-backends 'company-jedi))
   #+end_src
** Thrift
  #+begin_src emacs-lisp :tangle yes
    (use-package thrift
      :mode "\\.thrift$")
  #+end_src
** JSON
  #+begin_src emacs-lisp :tangle yes
    (use-package json)
  #+end_src

** Markdown
  #+begin_src emacs-lisp :tangle yes
    (use-package markdown-mode
       :mode (("\\.text\\'" . markdown-mode)
              ("\\.markdown\\'" . markdown-mode)
              ("README\\.md\\'" . gfm-mode)))
  #+end_src
** JS + Web
   Web mode is a very, very, very fine mode
   #+begin_src emacs-lisp :tangle yes
     (use-package js-comint)
     (use-package web-mode
       :mode "\\.phtml\\'"
       :mode "\\.[agj]sp\\'"
       :mode "\\.as[cp]x\\'"
       :mode "\\.erb\\'"
       :mode "\\.mustache\\'"
       :mode "\\.djhtml\\'"
       :mode "\\.html?\\'"
       :mode "\\.jsx?\\'"
       :bind
       (:map web-mode-map
             ("C-x C-e" . js-send-last-sexp)
             ("C-M-x" . js-send-last-sexp-and-go)
             ("C-c b" . js-send-buffer)
             ("C-c C-b" . js-send-buffer-and-go)
             ("C-c l" . js-load-file-and-go)
             )
       :config
       (setq web-mode-code-indent-offset 2
             web-mode-css-indent-offset 2
             web-mode-attr-indent-offset 2
             web-mode-enable-auto-closing t
             web-mode-enable-auto-indentation t
             web-mode-enable-auto-opening t
             web-mode-enable-auto-pairing t
             web-mode-enable-auto-quoting t
             web-mode-markup-indent-offset 2
             web-mode-script-padding 2
             web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'"))
             web-mode-style-padding 2)
       (font-lock-add-keywords
        'web-mode `(("\\(function *\\)("
                     (0 (progn (compose-region (match-beginning 1) (match-end 1) "ƒ")
                               nil)))))
       (setq-default flycheck-disabled-checkers
                     (append flycheck-disabled-checkers
                             '(javascript-jshint)))
       (flycheck-add-mode 'javascript-eslint 'web-mode)
       (defadvice web-mode-highlight-part (around tweak-jsx activate)
         (if (equal web-mode-content-type "jsx")
             (let ((web-mode-enable-part-face nil))
               ad-do-it)
           ad-do-it))
       (add-to-list 'web-mode-indentation-params '("lineup-calls" . nil))
       (add-to-list 'web-mode-indentation-params '("lineup-concats" . nil))
       (add-to-list 'web-mode-indentation-params '("lineup-ternary" . nil)))
   #+end_src
** Config File Formats
  #+begin_src emacs-lisp :tangle yes
    (use-package gitignore-mode)
    (use-package gitconfig-mode)
    (use-package hgignore-mode)
    (use-package hgrc-mode)
  #+end_src
* Which Key was that again?

  #+begin_src emacs-lisp :tangle yes
    (use-package which-key
      :diminish which-key-mode
      :config (which-key-mode 1))
  #+end_src
