#+TITLE: Emacs Configuration
#+AUTHOR: John Allen
#+STARTUP: overview

# Potential Future Improvements:
# - Consider migrating from yasnippet to tempel for templates
# - Consider ace-window instead of win-switch for window management

* Performance Optimizations

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Increase garbage collection threshold for faster startup
  ;; Default is 800KB, we set to 100MB during init
  (setq gc-cons-threshold (* 100 1024 1024))
  
  ;; Increase the amount of data Emacs reads from processes
  (setq read-process-output-max (* 1024 1024)) ; 1MB
  
  ;; Optimize file handling
  (setq auto-save-default t
        auto-save-timeout 20  ; seconds
        auto-save-interval 200) ; keystrokes
  
  ;; Disable bidirectional text for performance
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t)  ; Emacs 27+ only
  
  ;; Disable line numbers in non-programming modes for performance
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  
  ;; Optimize long line handling
  (setq-default truncate-lines t)
  (setq truncate-partial-width-windows nil)
  
  ;; Fast scrolling
  (setq fast-but-imprecise-scrolling t)
  (setq jit-lock-defer-time 0.05)
  
  ;; Increase undo limits for better experience
  (setq undo-limit 80000000         ; 80MB
        undo-strong-limit 120000000  ; 120MB
        undo-outer-limit 240000000)  ; 240MB
  
  ;; Optimize minibuffer
  (setq enable-recursive-minibuffers t)
  (setq max-mini-window-height 0.3)
  
  ;; Don't compact font caches during GC
  (setq inhibit-compacting-font-caches t)
  
  ;; Reset GC threshold after startup (defer this to the end)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 16 1024 1024))  ; 16MB
              (message "Startup time: %.2f seconds"
                       (float-time (time-subtract after-init-time before-init-time)))))
#+END_SRC

** Suppress Compilation Warnings

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Reduce byte-compile warnings from packages
  (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
  
  ;; Native compilation settings (Emacs 28+)
  (when (and (fboundp 'native-comp-available-p)
             (native-comp-available-p))
    ;; Suppress native comp warnings
    (setq native-comp-async-report-warnings-errors nil
          native-comp-warning-on-missing-source nil
          native-comp-verbose 0))
  
  ;; Suppress specific warning types
  (with-eval-after-load 'warnings
    (add-to-list 'warning-suppress-types '(comp))
    (add-to-list 'warning-suppress-types '(bytecomp))
    (add-to-list 'warning-suppress-types '(docstring)))
  
  ;; Quiet package.el
  (setq package-native-compile t)
  
  ;; Advice to reduce warnings during package operations
  (defun my/quieter-byte-compile (orig-fun &rest args)
    "Reduce verbosity during byte compilation."
    (let ((byte-compile-warnings '(not free-vars unresolved noruntime 
                                       lexical make-local docstring 
                                       obsolete))
          (inhibit-message t))
      (apply orig-fun args)))
  
  (advice-add 'byte-compile-file :around #'my/quieter-byte-compile)
#+END_SRC

* Mac Magic

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Keybindings
  (global-set-key [(hyper a)] 'mark-whole-buffer)
  (global-set-key [(hyper v)] 'yank)
  (global-set-key [(hyper c)] 'kill-ring-save)
  (global-set-key [(hyper s)] 'save-buffer)
  (global-set-key [(hyper l)] 'goto-line)
  (global-set-key [(hyper w)]
                  (lambda () (interactive) (delete-window)))
  (global-set-key [(hyper z)] 'undo)

  (setq mac-option-modifier 'meta)
  (setq mac-command-modifier 'hyper)
#+END_SRC

Mac tries to hide your $PATH from you when using a graphical mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

* Configure Completions

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package vertico
    :ensure t
    :diminish vertico-mode
    :init
    (savehist-mode 1)
    (recentf-mode 1)  ; Enable recent file tracking
    :config
    (vertico-mode 1)
    (setq vertico-cycle t
          vertico-count 15  ; Show more candidates
          recentf-max-saved-items 100  ; Track more recent files
          recentf-max-menu-items 15
          recentf-auto-cleanup 'never)  ; Don't cleanup on startup
    ;; Exclude some paths from recentf
    (add-to-list 'recentf-exclude "/tmp/")
    (add-to-list 'recentf-exclude "/var/")
    (add-to-list 'recentf-exclude ".gz\\'"))

  ;; Enable vertico directory navigation
  (use-package vertico-directory
    :after vertico
    :ensure nil  ; Part of vertico
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package marginalia
    :ensure t
    :after vertico
    :diminish marginalia-mode
    :config
    (marginalia-mode 1))

  (use-package consult
    :ensure t
    :bind (("C-x b" . consult-buffer)
           ("C-s" . consult-line)
           ("M-y" . consult-yank-pop)     ; Better kill-ring browsing
           ("M-o" . consult-find)
           ("M-l" . consult-goto-line)
           ("M-s l" . consult-locate)
           ("M-s g" . consult-git-grep)
           ("M-s s" . consult-ripgrep)
           ("M-s o" . consult-outline)     ; Navigate code structure
           ("C-x r l" . consult-bookmark)
           ("C-x r f" . consult-recent-file) ; Recent files
           ("C-c C-i" . consult-imenu))
    :init
    (setq consult-locate-args "mdfind -name %s 2>/dev/null"
          xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref
          consult-narrow-key "<")         ; Use < to narrow in consult commands
    :config
    ;; Preview customization for consult commands
    (setq consult-preview-key 'any))

  (use-package orderless
    :ensure t
    :init
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))

  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)         ;; pick some action on the current candidate
     ("C-;" . embark-dwim))       ;; "do what I mean" (contextual) action
    :init
    ;; Show Embark actions in the minibuffer-side window
    (setq embark-indicators '(embark-minimal-indicator embark-which-key-indicator))
    :config
    ;; Optionally, use which-key to display available actions
    (setq embark-which-key-prefix ","))

  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :config
    ;; If you want Embark actions to integrate with Consult previews:
    (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode))
#+END_SRC

* Customization File

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file (concat config-load-path "custom.el"))
  (load custom-file)
#+END_SRC

* Appearance

** Theme

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package tangotango-theme
    :ensure t
    :config
    (load-theme 'tangotango t))
#+END_SRC

isearch faces customizations

#+BEGIN_SRC emacs-lisp :tangle yes
  (set-face-foreground 'lazy-highlight "black")
  (set-face-background 'lazy-highlight "yellow")
  (set-face-foreground 'isearch "white")
  (set-face-background 'isearch "blue")
#+END_SRC

** Frame Settings

Frame Configuration

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq default-frame-alist
        (quote
         ((left-fringe . 1)
          (right-fringe . 1)
          (menu-bar-lines . 0)
          (tool-bar-lines . 0)
          (font . "Input Mono Narrow-16"))))
#+END_SRC

Uniquify Buffer Names

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package uniquify
    :ensure nil  ;; built-in
    :init
    (setq uniquify-buffer-name-style 'reverse
          uniquify-separator "|"
          uniquify-after-kill-buffer-p t
          uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

Show lines and columns

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq line-number-mode t
        column-number-mode t)
#+END_SRC

Show number and ordinality of matching

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Use built-in isearch-lazy-count (available in Emacs 27+)
  (setq isearch-lazy-count t)
  (setq isearch-lazy-count-format "(%s/%s) ")
#+END_SRC

Highlight the selected region

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq transient-mark-mode t)
#+END_SRC

https://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq scroll-step 1
        scroll-conservatively 10000
        mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
        mouse-wheel-follow-mouse t) ;; scroll window under mouse
#+END_SRC

** Turn Off NUX and Noisy UI

No scroll, tool, menu bars

#+BEGIN_SRC emacs-lisp :tangle yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

Scratch buffer can just be empty, thanks

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq initial-scratch-message nil)
#+END_SRC

No NUX

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inhibit-splash-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+END_SRC

No bell, thanks

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore)
#+END_SRC

* Navigation

** Enable ibuffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer-vc
    :ensure t
    :bind ("C-x C-b" . ibuffer)
    :init
    (setq ibuffer-default-sorting-mode 'major-mode))
#+END_SRC

** Save Point Positions Between Sessions

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package saveplace
    :config
    (setq-default save-place t)
    (setq save-place-file (expand-file-name ".places" "~/tmp/saves")))
#+END_SRC

** Window Management

Configure special buffer display behavior using native Emacs functionality

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Configure how specific buffers are displayed
  (setq display-buffer-alist
        '(;; Bottom side windows for various outputs
          ("\\*\\(compilation\\|grep\\|Compile-Log\\|Flymake\\)\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.3)
           (window-parameters . ((no-delete-other-windows . t)
                                 (mode-line-format . none))))

          ;; Help and documentation windows (including LSP)
          ("\\*\\(Help\\|helpful\\|info\\|lsp-help\\|eldoc\\)\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.33))

          ;; REPLs and interactive shells - these might want more space
          ("\\*\\(shell\\|eshell\\|term\\|vterm\\)\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.4)
           (window-parameters . ((no-delete-other-windows . t))))

          ;; Quick command output
          ("\\*Shell Command Output\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.25))

          ;; Async command output
          ("\\*Async Shell Command\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.25))

          ;; Warnings and errors - smaller since usually short
          ("\\*\\(Warnings\\|Backtrace\\|Messages\\|Errors\\)\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.25))

          ;; Completions - small popup
          ("\\*Completions\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.2))

          ;; Man pages - need more space
          ("\\*Man .*\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.5))

          ;; Occur results
          ("\\*Occur\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.3))

          ;; Package manager
          ("\\*Packages\\*"
           (display-buffer-same-window))

          ;; Process list
          ("\\*Process List\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.25))

          ;; Echo key buffer (from your config)
          ("\\*echo-key\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 10)
           (window-parameters . ((no-delete-other-windows . t))))

          ;; Version control
          ("\\*vc-\\(diff\\|change-log\\|log\\|dir\\)\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 0.3))

          ;; Org-mode special buffers
          ("\\*Org Src .*\\*"
           (display-buffer-same-window))

          ;; Calendar
          ("\\*Calendar\\*"
           (display-buffer-in-side-window)
           (side . bottom)
           (window-height . 10))

          ;; Bookmarks
          ("\\*Bookmark List\\*"
           (display-buffer-same-window))

          ;; Customization
          ("\\*Customize.*\\*"
           (display-buffer-same-window))))

  ;; Make it easy to close all side windows with one command
  (global-set-key (kbd "C-c w k") 'window-toggle-side-windows)
#+END_SRC

** Splitting

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq split-height-threshold 10000
        split-width-threshold 10000)
#+END_SRC

** Enable win-switch

Super nice to switch between frames and buffers

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package win-switch
    :bind (("C-x o" . win-switch-dispatch))
    :config
    (setq win-switch-provide-visual-feedback t
          win-switch-feedback-background-color "purple"
          win-switch-feedback-foreground-color "white")
    (win-switch-setup-keys-default))
#+END_SRC


** Expand Region

it's awesome

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :commands er/expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

** Configure Windmove

#+BEGIN_SRC emacs-lisp :tangle yes
  (windmove-default-keybindings 'hyper)
#+END_SRC

** Manipulate Window Sizes

C-x <arrow>

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key
   (kbd "C-x <right>")
   '(lambda () (interactive) (enlarge-window-horizontally 4)))
  (global-set-key
   (kbd "C-x <left>")
   '(lambda () (interactive) (shrink-window-horizontally 4)))
  (global-set-key
   (kbd "C-x <up>")
   '(lambda () (interactive) (enlarge-window 4)))
  (global-set-key
   (kbd "C-x <down>")
   '(lambda () (interactive) (shrink-window 4)))
#+END_SRC

** Searching

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq case-fold-search t)
  (setq tags-case-fold-search nil)
#+END_SRC

** Subword Movement in prog-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

** Replace 'yes/no' by Just 'y/n'

#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Editing

** Text-mode is a Better Default Than Fundamental for Me

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default major-mode 'text-mode)
#+END_SRC

** git-gutter-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter
    :diminish git-gutter-mode
    :commands (git-gutter-mode)
    :bind (:map vc-prefix-map
                ("[" . git-gutter:previous-hunk)
                ("]" . git-gutter:next-hunk)
                ("n" . git-gutter:revert-hunk)
                ("SPC" . git-gutter:mark-hunk))
    :init
    (global-git-gutter-mode)
    :config
    (setq git-gutter:handled-backends '(git)))
#+END_SRC

** Disable Warnings About Large Files

File Handling Optimizations

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Warn when opening large files (100MB)
  (setq large-file-warning-threshold (* 100 1024 1024))
  
  ;; Use fundamental-mode for very large files
  (defun my-large-file-hook ()
    "Optimize settings for large files."
    (when (> (buffer-size) large-file-warning-threshold)
      (setq buffer-read-only t)
      (buffer-disable-undo)
      (fundamental-mode)
      (message "Large file: disabled features for performance")))
  
  (add-hook 'find-file-hook 'my-large-file-hook)
#+END_SRC

** Snippets

Snippets are are awesome. They are found in ~/emacs.d/snippets

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet
    :diminish yas-minor-mode
    :config (yas-global-mode 1))
#+END_SRC

** Completions

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package corfu
    :ensure t
    ;; Optional customizations
    :custom
    (corfu-cycle t)                 ; Allows cycling through candidates
    (corfu-auto t)                  ; Enable auto completion
    (corfu-auto-prefix 2)           ; Minimum length of prefix for completion
    (corfu-auto-delay 0)            ; No delay for completion
    (corfu-popupinfo-delay '(0.5 . 0.2))  ; Automatically update info popup after that number of seconds
    (corfu-preview-current 'insert) ; insert previewed candidate
    (corfu-preselect 'prompt)
    (corfu-on-exact-match nil)      ; Don't auto expand tempel snippets
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
                ("M-SPC"      . corfu-insert-separator)
                ("TAB"        . corfu-next)
                ([tab]        . corfu-next)
                ("S-TAB"      . corfu-previous)
                ([backtab]    . corfu-previous)
                ("S-<return>" . corfu-insert)
                ("RET"        . corfu-insert))
    :init
    (global-corfu-mode)
    (corfu-history-mode)
    (corfu-popupinfo-mode) ; Popup completion info
    :config
    (add-hook 'eshell-mode-hook
              (lambda () (setq-local corfu-quit-at-boundary t
                                     corfu-quit-no-match t
                                     corfu-auto nil)
                (corfu-mode))
              nil
              t))
#+END_SRC

** Flycheck

Flycheck for use with LSPs

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :ensure t
    :hook
    (lsp-mode . flycheck-mode)
    :bind (:map flycheck-mode-map
                ("M-n" . flycheck-next-error)
                ("M-p" . flycheck-previous-error)))
#+END_SRC

** Multiple Cursors                                                             :today:

Multi-cursor editing is so cool when you can do it. Useful when
editing many similar lines. More interactive than macros.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :bind (("M-c" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)
           ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

** Revert a Buffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC

** Backups

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar user-temporary-file-directory "~/tmp/saves/"
    (concat temporary-file-directory user-login-name "/"))

  (make-directory user-temporary-file-directory t)

  (setq make-backup-files t
        backup-by-copying t      ; don't clobber symlinks
        backup-directory-alist
        `(("." . ,user-temporary-file-directory))    ; don't litter my fs tree
        delete-old-versions t
        kept-new-versions 3      ; Keep fewer versions for performance
        kept-old-versions 1
        version-control t)       ; use versioned backups

  (setq vc-make-backup-files t)

  (setq backup-directory-alist
        `((".*" . ,user-temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,user-temporary-file-directory t)))
  (setq auto-save-list-file-prefix
        (concat user-temporary-file-directory ".auto-saves-"))
#+END_SRC

** Revert Files When They Change On Disk

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-auto-revert-mode t)
#+END_SRC

** Make Scripts Executable on Save

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Unfill Paragraphs

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (global-set-key (kbd "M-Q") 'unfill-paragraph)
#+END_SRC

** Code Formatting

*** Columns

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq fill-column 78)
#+END_SRC

*** Default Indentation

Set default indentation to 4 spaces, not tabs.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Use spaces instead of tabs by default
  (setq-default indent-tabs-mode nil)
  
  ;; Set default tab width to 4 spaces
  (setq-default tab-width 4)
  
  ;; Set default indentation offset to 4
  (setq-default c-basic-offset 4)
  
  ;; For modes that use standard-indent
  (setq-default standard-indent 4)
#+END_SRC

*** Whitespace

I don't highlight trailing whitespace, because I auto-kill it anyway

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default show-trailing-whitespace nil)
#+END_SRC

And here we do the killing

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

*** Add Newline to the End of Files

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq require-final-newline t)
#+END_SRC

*** Set Unix File Coding System

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (setq-default default-buffer-file-coding-system 'utf-8-unix)
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+END_SRC

*** EditorConfig Support

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+END_SRC

** LSP

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Configure cape for additional completion sources with corfu
  (use-package cape
    :ensure t
    :init
    ;; Add useful Cape completion functions to completion-at-point-functions
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-keyword))

  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (which-key-mode)
    (setq which-key-idle-delay 0.5))

  (use-package hydra
    :ensure t
    :demand t)  ; Load immediately so hydras are available

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((lsp-mode           . lsp-enable-which-key-integration)
           ;; lsp-diagnostics-mode is now automatic, no need to hook
           (rust-ts-mode       . lsp-deferred)
           (c-ts-mode          . lsp-deferred)
           (c++-ts-mode        . lsp-deferred)
           (typescript-ts-mode . lsp-deferred)
           (tsx-ts-mode        . lsp-deferred)
           (js-ts-mode         . lsp-deferred)
           (go-ts-mode         . lsp-deferred)
           (python-ts-mode     . lsp-deferred))
    :custom
    (lsp-log-io nil)                      ; IMPORTANT! Use only for debugging! Drastically affects performance
    (lsp-keymap-prefix "C-c l")           ; Prefix for LSP actions
    (lsp-completion-provider :none)       ; Using Corfu as the provider
    (lsp-diagnostics-provider :flycheck)
    (lsp-session-file (locate-user-emacs-file ".lsp-session"))
    (lsp-keep-workspace-alive nil)        ; Close LSP server if all project buffers are closed
    (lsp-idle-delay 0.5)                  ; Debounce timer for `after-change-function'
    ;; Performance optimizations
    (lsp-log-max 1000)                    ; Reduce log size
    (lsp-file-watch-threshold 1000)       ; Don't watch too many files
    ;; core
    (lsp-enable-xref t)                   ; Use xref to find references
    (lsp-auto-configure t)                ; Used to decide between current active servers
    (lsp-eldoc-enable-hover t)            ; Display signature information in the echo area
    (lsp-enable-dap-auto-configure t)     ; Debug support
    (lsp-enable-file-watchers nil)        ; Disable for performance
    (lsp-enable-folding nil)              ; Not using folding
    (lsp-enable-imenu t)
    (lsp-enable-indentation nil)          ; I use prettier
    (lsp-enable-links nil)                ; No need since we have `browse-url'
    (lsp-enable-on-type-formatting nil)   ; Prettier handles this
    (lsp-enable-suggest-server-download t) ; Useful prompt to download LSP providers
    (lsp-enable-symbol-highlighting t)     ; Shows usages of symbol at point in the current buffer
    (lsp-enable-text-document-color nil)   ; This is Treesitter's job
    ;; UI settings are in lsp-ui package below
    ;; completion
    (lsp-completion-enable t)
    (lsp-completion-enable-additional-text-edit t) ; Ex: auto-insert an import for a completion candidate
    (lsp-enable-snippet t)
    (lsp-completion-show-kind t)                   ; Optional
    ;; headerline
    (lsp-headerline-breadcrumb-enable t)  ; Optional, I like the breadcrumbs
    (lsp-headerline-breadcrumb-enable-diagnostics nil) ; Don't make them red, too noisy
    (lsp-headerline-breadcrumb-enable-symbol-numbers nil)
    (lsp-headerline-breadcrumb-icons-enable nil)
    ;; modeline
    (lsp-modeline-code-actions-enable t) ; Modeline should be relatively clean
    (lsp-modeline-diagnostics-enable nil)  ; Already supported through `flycheck'
    (lsp-modeline-workspace-status-enable nil) ; Modeline displays "LSP" when lsp-mode is enabled
    (lsp-signature-doc-lines 1)           ; Don't raise the echo area. It's distracting
    (lsp-ui-doc-use-childframe t)         ; Show docs for symbol at point
    (lsp-eldoc-render-all nil)            ; This would be very useful if it would respect `lsp-signature-doc-lines', currently it's distracting
    ;; lens
    (lsp-lens-enable nil)                 ; Optional, I don't need it
    ;; semantic
    (lsp-semantic-tokens-enable nil)      ; Related to highlighting, and we defer to treesitter
    ;; C/C++
    (lsp-clients-clangd-args  '("--header-insertion=never"))
    ;; rust
    (lsp-rust-server 'rust-analyzer)
    (lsp-rust-analyzer-server-display-inlay-hints t)
    (lsp-rust-analyzer-proc-macro-enable t)
    (lsp-rust-analyzer-cargo-watch-command "clippy"))

  ;; Define LSP Hydra for better command organization
  (with-eval-after-load 'lsp-mode
    (defhydra hydra-lsp (:color blue :hint nil)
      "
 LSP Commands:
 ^Navigation^          ^Refactor^            ^Help^              ^Workspace^
 ^^^─────────────────  ^^^─────────────────  ^^^───────────────  ^^^─────────────────
 _g d_: definition     _r n_: rename         _h s_: show doc     _w r_: restart
 _g r_: references     _r a_: code action    _h h_: hide doc     _w s_: shutdown
 _g i_: implementation _r f_: format buffer  _h e_: errors       _w a_: add folder
 _g t_: type def       _r F_: format region  _h l_: lens toggle  _w d_: remove folder
 _g h_: hierarchy      _r o_: organize imp.  ^ ^                 _w l_: list folders
 "
      ;; Navigation
      ("g d" lsp-ui-peek-find-definitions)
      ("g r" lsp-ui-peek-find-references)
      ("g i" lsp-ui-peek-find-implementation)
      ("g t" lsp-find-type-definition)
      ("g h" lsp-treemacs-call-hierarchy)
      
      ;; Refactor
      ("r n" lsp-rename)
      ("r a" lsp-execute-code-action)
      ("r f" lsp-format-buffer)
      ("r F" lsp-format-region)
      ("r o" lsp-organize-imports)
      
      ;; Help
      ("h s" lsp-ui-doc-show)
      ("h h" lsp-ui-doc-hide)
      ("h e" lsp-treemacs-errors-list)
      ("h l" lsp-lens-mode)
      
      ;; Workspace
      ("w r" lsp-workspace-restart)
      ("w s" lsp-workspace-shutdown)
      ("w a" lsp-workspace-folders-add)
      ("w d" lsp-workspace-folders-remove)
      ("w l" lsp-describe-session)
      
      ("q" nil "quit"))
    
    ;; Bind the hydra to C-c l
    (define-key lsp-mode-map (kbd "C-c l") 'hydra-lsp/body))

  (use-package lsp-ui
    :after lsp-mode
    :commands (lsp-ui-mode lsp-ui-peek-find-definitions lsp-ui-peek-find-references)
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    ;; Sideline
    (lsp-ui-sideline-enable nil)              ; Disable sideline altogether
    (lsp-ui-sideline-show-hover nil)
    (lsp-ui-sideline-show-diagnostics t)      ; Show diagnostics if we enable sideline
    (lsp-ui-sideline-show-code-actions nil)   ; Too noisy
    (lsp-ui-sideline-diagnostic-max-lines 20) ; TypeScript errors can be long
    ;; Documentation
    (lsp-ui-doc-enable t)
    (lsp-ui-doc-delay 0.5)
    (lsp-ui-doc-show-with-cursor nil)         ; Don't auto-show on cursor
    (lsp-ui-doc-show-with-mouse t)            ; Show on mouse hover
    (lsp-ui-doc-position 'at-point)           ; Show at point, not top
    (lsp-ui-doc-use-webkit nil)               ; Webkit can be buggy
    ;; Peek
    (lsp-ui-peek-enable t)
    (lsp-ui-peek-peek-height 20)
    (lsp-ui-peek-list-width 50)
    (lsp-ui-peek-always-show t)
    ;; Misc
    (lsp-ui-imenu-enable t)
    (lsp-ui-imenu-kind-position 'left))
#+END_SRC

* Utilities

** Edit Current Buffer As root

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun sudo ()
    "Use TRAMP to `sudo' the current buffer"
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))
#+END_SRC

** Sort Lines In Paragraph

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun jallen-sort-para ()
    "Sorts the paragraph in which the point is located"
    (interactive)
    (save-excursion
      (let (bpoint epoint)
        (backward-paragraph)
        (setq bpoint (point))
        (forward-paragraph)
        (setq epoint (point))
        (sort-lines nil bpoint epoint))))
#+END_SRC

** Increment/Decrement Number at Point

Because why not?

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun increment-number-at-point ()
    (interactive)
    (skip-chars-backward "0-9")
    (or (looking-at "[0-9]+")
        (error "No number at point"))
    (replace-match (number-to-string (1+ (string-to-number (match-string 0))))))

  (defun decrement-number-at-point ()
    (interactive)
    (skip-chars-backward "0-9")
    (or (looking-at "[0-9]+")
        (error "No number at point"))
    (replace-match (number-to-string (- (string-to-number (match-string 0)) 1))))
#+END_SRC

** Better regex-builder

'string' does not require the crazy double escape thing from emacs regexes

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package re-builder
    :config
    (setq reb-re-syntax 'string))
#+END_SRC

** echo-keys

This is useful for screen capture videos

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar *echo-keys-last* nil "Last command processed by `echo-keys'.")

  (defun echo-keys ()
    (interactive)
    (let ((deactivate-mark deactivate-mark))
      (when (this-command-keys)
        (with-current-buffer (get-buffer-create "*echo-key*")
          (goto-char (point-max))
          ;; self  self
          ;; self  other \n
          ;; other self  \n
          ;; other other \n
          (unless (and (eq 'self-insert-command *echo-keys-last*)
                       (eq 'self-insert-command this-command))
            (insert "\n"))
          (if (eql this-command 'self-insert-command)
              (let ((desc (key-description (this-command-keys))))
                (if (= 1 (length desc))
                    (insert desc)
                  (insert " " desc " ")))
            (insert (key-description (this-command-keys))))
          (setf *echo-keys-last* this-command)
          (dolist (window (window-list))
            (when (eq (window-buffer window) (current-buffer))
              ;; We need to use both to get the effect.
              (set-window-point window (point))
              (end-of-buffer)))))))

  (defun toggle-echo-keys ()
    (interactive)
    (if (member 'echo-keys  pre-command-hook)
        (progn
          (remove-hook 'pre-command-hook 'echo-keys)
          (dolist (window (window-list))
            (when (eq (window-buffer window) (get-buffer "*echo-key*"))
              (delete-window window))))
      (progn
        (add-hook    'pre-command-hook 'echo-keys)
        (delete-other-windows)
        (split-window nil (- (window-width) 32) t)
        (other-window 1)
        (switch-to-buffer (get-buffer-create "*echo-key*"))
        (set-window-dedicated-p (selected-window) t)
        (other-window 1))))
#+END_SRC

** Toggle Magic

https://endlessparentheses.com/the-toggle-map-and-wizardry.html

#+BEGIN_SRC emacs-lisp :tangle yes
  (define-prefix-command 'endless/toggle-map)
  ;; The manual recommends C-c for user keys, but C-x t is
  ;; always free, whereas C-c t is used by some modes.
  (define-key ctl-x-map "t" 'endless/toggle-map)
  (define-key endless/toggle-map "c" #'column-number-mode)
  (define-key endless/toggle-map "d" #'toggle-debug-on-error)
  (define-key endless/toggle-map "e" #'toggle-debug-on-error)
  (define-key endless/toggle-map "f" #'auto-fill-mode)
  (define-key endless/toggle-map "l" #'toggle-truncate-lines)
  (define-key endless/toggle-map "q" #'toggle-debug-on-quit)
  ;;; Generalized version of `read-only-mode'.
  (define-key endless/toggle-map "r" #'dired-toggle-read-only)
  (autoload 'dired-toggle-read-only "dired" nil t)
  (define-key endless/toggle-map "w" #'whitespace-mode)
#+END_SRC

** Project Management

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :config
    (projectile-mode +1)
    (setq projectile-project-search-path '("~/am/")
          projectile-completion-system 'consult)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))

  (defun compile-go-project ()
    "Compile current Go project using make build"
    (interactive)
    (compile "make build"))

  (defun test-go-project ()
    "Test current Go project using make test"
    (interactive)
    (compile "make test"))

  (defun lint-go-project ()
    "Lint current Go project using make lint"
    (interactive)
    (compile "make lint"))

  (defun format-go-project ()
    "Format current Go project using make fmt"
    (interactive)
    (compile "make fmt"))

  (defun compile-ts-project ()
    "Compile current TypeScript project using turbo build"
    (interactive)
    (compile "turbo build"))

  (defun test-ts-project ()
    "Test current TypeScript project using turbo test"
    (interactive)
    (compile "turbo test"))

  (defun dev-ts-project ()
    "Start dev server for TypeScript project using turbo dev"
    (interactive)
    (compile "turbo dev"))

  (global-set-key (kbd "C-c m b") 'compile-go-project)
  (global-set-key (kbd "C-c m t") 'test-go-project)
  (global-set-key (kbd "C-c m l") 'lint-go-project)
  (global-set-key (kbd "C-c m f") 'format-go-project)
  (global-set-key (kbd "C-c m B") 'compile-ts-project)
  (global-set-key (kbd "C-c m T") 'test-ts-project)
  (global-set-key (kbd "C-c m d") 'dev-ts-project)
#+END_SRC


* Version Control

** Magit - Git Integration

Magit is the best Git interface for Emacs. It provides a complete Git porcelain inside Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :after hydra  ; Ensure hydra is loaded first
    :bind (("C-x g" . magit-status)
           ("C-x M-g" . magit-dispatch)
           ("C-c g" . hydra-magit/body))
    :config
    ;; Show word-granularity differences within diff hunks
    (setq magit-diff-refine-hunk t)
    ;; Don't show recent commits in magit-status
    (setq magit-log-section-commit-count 0)
    ;; Speed up magit
    (setq magit-refresh-status-buffer nil)
    ;; Open magit status in same window
    (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    
    ;; Define Magit Hydra
    (defhydra hydra-magit (:color blue :hint nil)
      "
 Git Commands:
 ^Status^      ^Branch^           ^Actions^          ^History^
 ^^^─────────  ^^^──────────────  ^^^──────────────  ^^^─────────────
 _s_: status   _b_: checkout      _c_: commit        _l_: log current
 _d_: diff     _B_: new branch    _p_: push          _L_: log all
 _S_: stage    _m_: merge         _P_: pull          _t_: timemachine
 _u_: unstage  _r_: rebase        _f_: fetch         _h_: file history
 _z_: stash    _R_: branch mgr    _M_: remotes       _H_: reflog
 "
      ;; Status
      ("s" magit-status)
      ("d" magit-diff-dwim)
      ("S" magit-stage-file)
      ("u" magit-unstage-file)
      ("z" magit-stash)
      
      ;; Branch
      ("b" magit-checkout)
      ("B" magit-branch-create)
      ("m" magit-merge)
      ("r" magit-rebase)
      ("R" magit-branch)
      
      ;; Actions
      ("c" magit-commit)
      ("p" magit-push-current)
      ("P" magit-pull-current)
      ("f" magit-fetch)
      ("M" magit-remote)
      
      ;; History
      ("l" magit-log-current)
      ("L" magit-log-all)
      ("t" git-timemachine)
      ("h" magit-log-buffer-file)
      ("H" magit-reflog-current)
      
      ("g" magit-refresh "refresh")
      ("q" nil "quit")))

  ;; Show git diff indicators in the fringe
  (use-package diff-hl
    :ensure t
    :hook ((prog-mode . diff-hl-mode)
           (magit-pre-refresh . diff-hl-magit-pre-refresh)
           (magit-post-refresh . diff-hl-magit-post-refresh))
    :config
    (diff-hl-flydiff-mode))

  ;; Browse file history
  (use-package git-timemachine
    :ensure t
    :bind ("C-x v t" . git-timemachine))

  ;; GitHub/GitLab integration (requires Magit)
  (use-package forge
    :ensure t
    :after magit)

#+END_SRC

* Terminal Configuration

** Terminals in Emacs Should Use ANSI Colors

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ansi-color)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  (setq comint-prompt-read-only t)
#+END_SRC

** Deal with Running Emacs in Terminal

Here is some scar tissue of me trying to make all keys work in the
terminal as they do in X11. This isn't possible as far as I can tell,
and I'm no longer sure if this does anything for me.

we are expecting an xterm compatible terminal here. tmux requires you
to set xterm-mode as a terminal option for this

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice terminal-init-xterm (after map-S-up-escape-sequence activate)
    (define-key input-decode-map "\e[1;9A" [M-up])
    (define-key input-decode-map "\e[1;9B" [M-down])
    (define-key input-decode-map "\e[1;9C" [M-right])
    (define-key input-decode-map "\e[1;9D" [M-left])

    (define-key input-decode-map "\e[1;10A" [M-S-up])
    (define-key input-decode-map "\e[1;10B" [M-S-down])
    (define-key input-decode-map "\e[1;10C" [M-S-right])
    (define-key input-decode-map "\e[1;10D" [M-S-left])

    ;; weird
    (global-set-key [select] [S-up]))
#+END_SRC

* Compilation

** Performance Settings

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Optimize compilation buffer performance
  (setq compilation-scroll-output t
        compilation-always-kill t        ; Kill old compilation process before starting new
        compilation-skip-threshold 2)    ; Skip warnings
  
  ;; Limit compilation buffer size
  (add-hook 'compilation-filter-hook
            (lambda ()
              (when (> (buffer-size) (* 256 1024)) ; 256KB limit
                (let ((inhibit-read-only t))
                  (delete-region (point-min) (/ (point-max) 2))))))
#+END_SRC

If I'm compiling, just save all the buffers automatically for me

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq compilation-ask-about-save nil)
#+END_SRC

And make some nice hotkeys

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "<f6>") 'compile)
  (global-set-key (kbd "<f7>") 'next-error) ;; can make this not global
#+END_SRC

And follow the output!!!

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq compilation-scroll-output 'first-error)
#+END_SRC

** Colors

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ansi-color)

  (defun colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

* Simple Behavior Customizations

** Set fill-column to Sensible Default for Me

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq fill-column 78)
#+END_SRC

** Tags Operations Should Be Case Sensitive

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq tags-case-fold-search nil)
#+END_SRC

** Smooth Scrolling

https://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq scroll-step 1
        scroll-conservatively 10000
        mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
        mouse-wheel-follow-mouse t) ;; scroll window under mouse
#+END_SRC

** Screen Splitting

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq split-height-threshold 10000
        split-width-threshold 10000)
#+END_SRC

** No Bell, Thanks

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore)
#+END_SRC

** Search/Match Should Be Case Insensitive

The documentation is actually a little misleading. The search will
be case sensitive if the search string has any capital characters in
it.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq case-fold-search t)
#+END_SRC

* Org Mode Configuration

Streamlined and modernized org-mode configuration based on years of GTD usage.

** Core Settings

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :ensure nil  ; Built-in
    :mode (("\\.org\\'" . org-mode)
           ("\\.org_archive\\'" . org-mode))
    :bind (("C-c l" . org-store-link)
           ("C-c a" . org-agenda)
           ("C-c c" . org-capture)
           ("C-c b" . org-switchb))
    :custom
    ;; Directories
    (org-directory "~/org/")
    (org-default-notes-file (concat org-directory "notes.org"))
    
    ;; Appearance
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-startup-indented t)
    (org-startup-folded 'content)
    (org-ellipsis " ⤵")
    (org-hide-leading-stars t)
    
    ;; Behavior
    (org-catch-invisible-edits 'smart)
    (org-special-ctrl-a/e t)
    (org-insert-heading-respect-content t)
    (org-return-follows-link t)
    (org-use-speed-commands t)
    (org-enforce-todo-dependencies t)
    (org-agenda-sticky t)
    (org-cycle-separator-lines 0)
    
    ;; Source blocks
    (org-src-fontify-natively t)
    (org-src-tab-acts-natively t)
    (org-src-preserve-indentation t)
    (org-edit-src-content-indentation 0)
    (org-confirm-babel-evaluate nil)
    
    :config
    ;; Load modules
    (setq org-modules '(org-habit org-id))
    
    ;; Better RET behavior
    (add-hook 'org-mode-hook
              (lambda ()
                (electric-indent-local-mode -1))))
#+END_SRC

** GTD Setup

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; GTD keywords and workflow
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
          (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")))
  
  (setq org-todo-keyword-faces
        '(("TODO" :foreground "red" :weight bold)
          ("NEXT" :foreground "blue" :weight bold)
          ("DONE" :foreground "forest green" :weight bold)
          ("WAITING" :foreground "orange" :weight bold)
          ("HOLD" :foreground "magenta" :weight bold)
          ("CANCELLED" :foreground "forest green" :weight bold)))
  
  ;; Auto-update tags based on TODO state
  (setq org-todo-state-tags-triggers
        '(("CANCELLED" ("CANCELLED" . t))
          ("WAITING" ("WAITING" . t))
          ("HOLD" ("WAITING") ("HOLD" . t))
          (done ("WAITING") ("HOLD"))
          ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
          ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))))
  
  ;; Tags
  (setq org-tag-alist
        '((:startgroup)
          ("@work" . ?w)
          ("@home" . ?h)
          ("@computer" . ?c)
          ("@anywhere" . ?a)
          (:endgroup)
          ("WAITING" . ?W)
          ("HOLD" . ?H)
          ("CANCELLED" . ?C)))
  
#+END_SRC

** Capture Templates

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/org-capture-target-at-heading ()
    "Return a point marker at the current heading."
    (save-excursion
      (org-back-to-heading)
      (point-marker)))
  
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline (concat org-directory "gtd.org") "Inbox")
           "* TODO %?\n  %i\n  %a")
          
          ("n" "Note" entry (file+datetree org-default-notes-file)
           "* %? :NOTE:\n  %U\n  %a")
          
          ("j" "Journal" entry (file+datetree (concat org-directory "journal.org"))
           "* %?\n  %U\n  %i")
          
          ("5" "5 Minute Journal")
          ("5m" "Morning Entry" entry (file+datetree (concat org-directory "5-min-journal.org"))
           "* Morning\n  I am grateful for...\n  - %?\n  - \n  - \n\n  What will I do to make today great?\n  - \n  - \n  - \n\n  I am ...")
          ("5e" "Evening Entry" entry (file+datetree (concat org-directory "5-min-journal.org"))
           "* Evening\n  3 amazing things that happened today...\n  - %?\n  - \n  - \n\n  How could I have made today even better?\n  - \n")
          
          ("." "Note at point" item
           (function my/org-capture-target-at-heading)
           "%? %U"
           :prepend t)))
  
  ;; Save buffer after capture
  (add-hook 'org-capture-before-finalize-hook
            (lambda () (save-buffer)))
#+END_SRC

** Agenda Configuration

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Agenda files
  (setq org-agenda-files (list org-directory))
  
  ;; Agenda appearance
  (setq org-agenda-window-setup 'current-window
        org-agenda-restore-windows-after-quit t
        org-agenda-span 'day
        org-agenda-start-with-log-mode t
        org-agenda-log-mode-items '(closed state)
        org-columns-default-format "%50ITEM(Task) %2PRIORITY")
  
  ;; Better time grid
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  
  ;; Custom commands
  (setq org-agenda-custom-commands
        '(("n" "Next Actions" tags-todo "-WAITING-CANCELLED/!NEXT"
           ((org-agenda-overriding-header "Next Actions")
            (org-agenda-sorting-strategy '(category-keep))))
          
          ("w" "Waiting" todo "WAITING"
           ((org-agenda-overriding-header "Waiting")))
          
          ("d" "Daily Review"
           ((agenda "" ((org-agenda-span 'day)))
            (tags-todo "-WAITING-CANCELLED/!NEXT"
                       ((org-agenda-overriding-header "Next Actions")))
            (todo "WAITING"
                  ((org-agenda-overriding-header "Waiting")))))))
  
  ;; Highlight current line in agenda
  (add-hook 'org-agenda-finalize-hook
            (lambda () (hl-line-mode 1)))
#+END_SRC

** Refile Settings

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Refile targets
  (setq org-refile-targets
        '((nil :maxlevel . 3)
          (org-agenda-files :maxlevel . 3)))
  
  ;; Create parent nodes if needed
  (setq org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil
        org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

** Modern Enhancements

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Modern bullets
  (use-package org-bullets
    :ensure t
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
  
  ;; Even better modern appearance
  (use-package org-modern
    :ensure t
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize . org-modern-agenda))
    :custom
    (org-modern-star '("◉" "○" "✸" "✿"))
    (org-modern-checkbox '((?X . "☑")
                          (?- . "☐")
                          (?\s . "☐")))
    (org-modern-table t))
  
  ;; Super agenda for better grouping
  (use-package org-super-agenda
    :ensure t
    :after org-agenda
    :config
    (org-super-agenda-mode)
    :custom
    (org-super-agenda-groups
     '((:name "Today"
              :time-grid t
              :scheduled today
              :deadline today)
       (:name "Important"
              :priority "A")
       (:name "Next"
              :todo "NEXT")
       (:name "Waiting"
              :todo "WAITING"))))
#+END_SRC

** Habits

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-habit)
  (setq org-habit-preceding-days 14
        org-habit-following-days 1
        org-habit-show-habits-only-for-today nil
        org-habit-graph-column 60)
#+END_SRC

** Logging

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Log settings
  (setq org-log-done 'time              ; Log time when task is done
        org-log-into-drawer t           ; Put timestamps in drawer
        org-edit-timestamp-down-means-later t)
#+END_SRC

** Helper Functions

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Quick org file access
  (defun my/org-find-file ()
    "Quickly open org files."
    (interactive)
    (find-file 
     (completing-read "Org file: "
                      (directory-files org-directory nil "\\.org$")
                      nil t)))
  
  ;; Clean up source blocks
  (defun my/org-cleanup-src-block ()
    "Format the current source block."
    (interactive)
    (org-edit-special)
    (indent-region (point-min) (point-max))
    (org-edit-src-exit))
  
  (define-key org-mode-map (kbd "C-c C-v C-f") 'my/org-cleanup-src-block)
#+END_SRC

* Modes

** Tree-sitter Configuration (Built-in Emacs 29+)

Using built-in tree-sitter support instead of external packages

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Ensure tree-sitter grammars are installed
  ;; Run M-x treesit-install-language-grammar to install grammars

  ;; Configure automatic mode selection for tree-sitter modes
  (setq treesit-language-source-alist
        '((bash       "https://github.com/tree-sitter/tree-sitter-bash")
          (c          "https://github.com/tree-sitter/tree-sitter-c")
          (cpp        "https://github.com/tree-sitter/tree-sitter-cpp")
          (css        "https://github.com/tree-sitter/tree-sitter-css")
          (go         "https://github.com/tree-sitter/tree-sitter-go")
          (html       "https://github.com/tree-sitter/tree-sitter-html")
          (java       "https://github.com/tree-sitter/tree-sitter-java")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript")
          (json       "https://github.com/tree-sitter/tree-sitter-json")
          (markdown   "https://github.com/tree-sitter-grammars/tree-sitter-markdown")
          (python     "https://github.com/tree-sitter/tree-sitter-python")
          (ruby       "https://github.com/tree-sitter/tree-sitter-ruby")
          (rust       "https://github.com/tree-sitter/tree-sitter-rust")
          (tsx        "https://github.com/tree-sitter/tree-sitter-typescript" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "typescript/src")
          (yaml       "https://github.com/tree-sitter-grammars/tree-sitter-yaml")))

  ;; Auto-install missing grammars
  (defun treesit-install-all-languages ()
    "Install all tree-sitter grammars."
    (interactive)
    (dolist (lang treesit-language-source-alist)
      (unless (treesit-language-available-p (car lang))
        (treesit-install-language-grammar (car lang)))))

  ;; Remap major modes to use tree-sitter variants
  (setq major-mode-remap-alist
        '((c-mode          . c-ts-mode)
          (c++-mode        . c++-ts-mode)
          (python-mode     . python-ts-mode)
          (javascript-mode . js-ts-mode)
          (js-mode         . js-ts-mode)
          (js2-mode        . js-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (rust-mode       . rust-ts-mode)
          (go-mode         . go-ts-mode)
          (ruby-mode       . ruby-ts-mode)
          (java-mode       . java-ts-mode)
          (html-mode       . html-ts-mode)
          (css-mode        . css-ts-mode)
          (json-mode       . json-ts-mode)
          (yaml-mode       . yaml-ts-mode)
          (sh-mode         . bash-ts-mode)))

  ;; Configure file associations for TypeScript/TSX
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . tsx-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.mjs\\'" . js-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.cjs\\'" . js-ts-mode))

  ;; Enable font-lock (syntax highlighting) for tree-sitter modes
  (global-font-lock-mode t)

  ;; Set tree-sitter font-lock level (1-4, higher = more detailed)
  (setq treesit-font-lock-level 4)
#+END_SRC

To install tree-sitter grammars:
1. Run `M-x treesit-install-language-grammar` for individual languages
2. Or run `M-x treesit-install-all-languages` to install all configured grammars
3. Grammars are installed to `~/.emacs.d/tree-sitter/` by default

** ediff

Add a special command line switch to emacs so that we can easily use
emacs as our diff tool.

#+BEGIN_SRC bash
emacs -diff file1 file2
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun command-line-diff (switch)
    (let ((file1 (pop command-line-args-left))
          (file2 (pop command-line-args-left)))
      (ediff file1 file2)))

  (add-to-list 'command-switch-alist '("diff" . command-line-diff))

  (add-hook 'ediff-load-hook
            (lambda ()
              (message "getting my diff onnnnn")
              (setq ediff-highlight-all-diffs nil)
              (set-face-background
               ediff-current-diff-face-A "#1e2424")
              (set-face-background
               ediff-current-diff-face-B "#1e2424")
              (set-face-background
               ediff-current-diff-face-C "#1e2424")
              (make-face-italic
               ediff-current-diff-face-A)
              (make-face-italic
               ediff-current-diff-face-B)
              (make-face-italic
               ediff-current-diff-face-C)))
#+END_SRC

** elisp

*** Turn on eldoc-mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eldoc
    :diminish eldoc-mode
    :config (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+END_SRC

*** Enable slime-nav

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package elisp-slime-nav
    :diminish elisp-slime-nav-mode
    :config
    (add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t))))
#+END_SRC

*** Enable =rainbow-delimiters=

But only for emacs-lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :config
    (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

*** package-lint for Authoring Packages

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package package-lint)
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package markdown-mode
    :mode (("\\.text\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode)
           ("README\\.md\\'" . gfm-mode)))
#+END_SRC

** YAML

Enable =yaml-mode=

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yaml-mode
    :mode (("\\.lock$" . yaml-ts-mode)
           ("\\.yml$" . yaml-ts-mode)
           ("\\.yaml$" . yaml-ts-mode)))
#+END_SRC

** Protobuf

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package protobuf-mode
    :ensure t
    :mode "\\.proto\\'"
    :config
    (setq protobuf-mode-indent-level 2))
#+END_SRC

** Web Dev

Meat and potatoes

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package typescript-ts-mode
    :mode (("\\.tsx\\'" . tsx-ts-mode)
           ("\\.js\\'"  . typescript-ts-mode)
           ("\\.mjs\\'" . typescript-ts-mode)
           ("\\.mts\\'" . typescript-ts-mode)
           ("\\.cjs\\'" . typescript-ts-mode)
           ("\\.ts\\'"  . typescript-ts-mode)
           ("\\.jsx\\'" . tsx-ts-mode))
    :hook ((typescript-ts-mode . lsp-deferred)
           (tsx-ts-mode . lsp-deferred)))

  (use-package tide
    :ensure t
    :after (typescript-ts-mode flycheck)
    :hook ((typescript-ts-mode . tide-setup)
           (typescript-ts-mode . tide-hl-identifier-mode)
           (tsx-ts-mode . tide-setup)
           (tsx-ts-mode . tide-hl-identifier-mode))
    :config
    (setq tide-completion-detailed t
          tide-always-show-documentation t))

  (use-package jest
    :ensure t
    :bind (:map typescript-ts-mode-map
                ("C-c t j" . jest-popup))
    :config
    (setq jest-executable "pnpm test"))

  (use-package npm-mode
    :ensure t
    :hook ((typescript-ts-mode . npm-mode)
           (tsx-ts-mode . npm-mode))
    :config
    (setq npm-mode-command-prefix "C-c n"))

  (use-package nodejs-repl
    :ensure t
    :bind (:map typescript-ts-mode-map
                ("C-c r" . nodejs-repl)))

  (use-package add-node-modules-path
    :ensure t
    :hook ((typescript-ts-mode . add-node-modules-path)
           (tsx-ts-mode . add-node-modules-path)))
#+END_SRC

Pug Templates for my JS misadventures

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pug-mode
    :ensure t
    :mode "\\.pug\\'"
    :config
    (setq pug-tab-width 2)
    (add-hook 'pug-mode-hook 'electric-indent-local-mode))
#+END_SRC

Prettier Formatting

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package apheleia
    :ensure apheleia
    :diminish ""
    :defines
    apheleia-formatters
    apheleia-mode-alist
    :functions
    apheleia-global-mode
    :config
    (setf (alist-get 'prettier-json apheleia-formatters)
          '("prettier" "--stdin-filepath" filepath))
    (apheleia-global-mode +1))
#+END_SRC

** C / C++

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package cc-mode
    :ensure nil
    :hook
    ((c-mode . (lambda ()
                 ;; C mode uses default 4 spaces from global config
                 ))
     (c++-mode . (lambda ()
                   ;; C++ mode uses default 4 spaces from global config
                   )))
    :config
    ;; Example: bind "go to definition" to F12
    (define-key c-mode-base-map (kbd "<f12>") 'lsp-find-definition)
    (define-key c-mode-base-map (kbd "C-c h")  'lsp-describe-thing-at-point))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rust-mode
    :ensure t
    :bind (("C-c C-s" . rust-compile)
           ("C-c C-t" . rust-test))
    :config
    (setq rust-format-on-save t)
    :hook (rust-mode . (lambda ()
                         ;; Use spaces, not tabs
                         (setq indent-tabs-mode nil)
                         (setq tab-width 4))))

  (use-package cargo
    :ensure t
    :hook
    (rust-mode . cargo-minor-mode))

  (use-package toml-mode
    :ensure t
    :mode "\\.toml\\'")
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package go-mode
    :ensure t
    :mode "\\.go\\'"
    :hook ((go-mode . (lambda ()
                        (setq indent-tabs-mode t)
                        (setq tab-width 4))))
    :config
    (setq gofmt-command "gofumpt")
    (add-hook 'before-save-hook 'gofmt-before-save))

  (use-package go-tag
    :ensure t
    :bind (:map go-mode-map
                ("C-c t a" . go-tag-add)
                ("C-c t r" . go-tag-remove)))

  (use-package gotest
    :ensure t
    :bind (:map go-mode-map
                ("C-c t f" . go-test-current-file)
                ("C-c t t" . go-test-current-test)
                ("C-c t p" . go-test-current-project)
                ("C-c t b" . go-test-current-benchmark)))

  (use-package go-eldoc
    :ensure t
    :hook (go-mode . go-eldoc-setup))

  (use-package go-guru
    :ensure t
    :hook (go-mode . go-guru-hl-identifier-mode))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package python
    :ensure nil
    :mode ("\\.py\\'" . python-mode)
    :hook ((python-mode . (lambda ()
                            (setq indent-tabs-mode nil)
                            (setq python-indent-offset 4))))
    :config
    (setq python-shell-interpreter "python3"
          python-shell-interpreter-args "-i"))
#+END_SRC
